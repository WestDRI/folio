<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>École hivernale de visualisation &nbsp; (EN | FR) – Various courses</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-4d9afe2b8d18ee9fa5d0d57b5ed4214d.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-960d9d362f81d399278ec3e29b622b37.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-b6871152dc33c25e97e10f79624f84be.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="site_libs/bootstrap/bootstrap-960d9d362f81d399278ec3e29b622b37.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles-ls.css">
</head>

<body class="quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">École hivernale de visualisation &nbsp; (<a href="winterseries">EN</a> | FR)</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>À l’exception de l’atelier Matplotlib du 20 janvier (voir les détails ci-dessous), tous les ateliers débutent à 10h (heure du Pacifique) / 11h (heure des Rocheuses) / 13h (heure de l’Est) / 14h (heure de l’Atlantique). Le matériel de formation sera ajouté à cette page après chaque session.</p>
<p>Vous pouvez vous inscrire <a href="https://forms.gle/XyjAMRDAM4A3DCr7A" target="_blank">ici</a> – veuillez sélectionner tous les ateliers auxquels vous voulez participer.</p>
<p>Cliquez sur chaque séance pour plus de détails et pour le lien calendrier.</p>
<details>
<summary>
<strong>Jan-20, 10am PT – <span style="font-size: 1.2em;">Intro session: which tool is right for me? (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Alex Razoumov (SFU)</p>
<p><strong>Abstract</strong>: This overview session introduces all workshops in the Series and provides high-level answers to questions such as:</p>
<ul>
<li>What are the differences among Python plotting libraries – Matplotlib, Seaborn, Plotly, Vega-Altair, and Plotnine – and when should you choose one over another?</li>
<li>Why use ParaView for 3D scientific visualization, and what are its core capabilities?</li>
<li>In what ways can you use Python scripting in ParaView? (There is more than one!)</li>
<li>What are the three primary approaches to creating animations in ParaView?</li>
<li>What is in-situ visualization?</li>
<li>Any domain-specific visualization tools covered in this Series?</li>
<li>Which scientific web visualization tools should you consider using in 2026?</li>
</ul>
<p>We will also briefly cover tools not included in this Series, such as VisIt, Python mapping packages, Julia plotting libraries, and others, and explain why they were left out.</p>
<p><a href="files/winterSeries/intro.pdf">PDF slides</a></p>
</div>
</details>
<details>
<summary>
<strong>Jan-20, <strong>11am</strong> PT – <span style="font-size: 1.2em;">Plotting in Python with Matplotlib (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Yohai Meiron (Univ. of Toronto)</p>
<p><strong>Abstract</strong>: Matplotlib is the foundational plotting library for Python, and is widely used in tandem with other scientific libraries (such as NumPy and Pandas) to visualize data across many different fields. It is a free and open source software library that offers fine-grained control over every aspect of a plot, making it a powerful tool for customizing figures to meet specific needs. In this workshop, we will use a Jupyter notebook to show you how to create common 2D plot types such as line, scatter, and heatmaps, and how to customize the labels, legend, and panel layout. We will briefly touch on using Matplotlib to produce animations and interactive visualizations. By the end of this one-hours session, you will have a basic understanding of the library’s capabilities.</p>
<!-- **Alex's Abstract**: Matplotlib is the original Python plotting library developed in the early 2000s. Designed -->
<!-- for rendering static plots in neurobiology, it came into the world dominated by proprietary plotting -->
<!-- packages. It is still widely used today across all scientific fields, and its rendering engine is utilized by -->
<!-- many other Python plotting packages. In this workshop, we will go through the major plot types supported by -->
<!-- Matplotlib, and toward the end we we also look at creating animations and adding interactivity to our plots. -->
<p><a href="https://pages.scinet.utoronto.ca/~ymeiron/matplotlib-demo.ipynb" target="_blank">Python notebook</a> (external link)   <a href="files/winterSeries/matplotlib.pdf">Notebook in PDF format</a></p>
</div>
</details>
<details>
<summary>
<strong>Jan-27, 10am PT – <span style="font-size: 1.2em;">Plotting in Python with Seaborn (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Jarno van der Kolk (Univ. of Ottawa)</p>
<p><strong>Abstract</strong>: Seaborn is a Python data visualization library based on matplotlib. It provides a high-level interface for drawing attractive and informative statistical graphics and is particularly well suited for displaying multi-dimensional data to get quick insight in a dataset.</p>
<p><strong>Prerequisites</strong>: Some knowledge of Python.</p>
<p><a href="https://codeberg.org/uOttawa-IT-Research/seaborn-workshop" target="_blank">Python notebook</a> (external GitHub repo)   <a href="files/winterSeries/seaborn.pdf">Notebook in PDF format</a></p>
</div>
</details>
<details>
<summary>
<strong>Jan-30, 10am PT – <span style="font-size: 1.2em;">Plotting in Python with Plotly (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Alex Razoumov (SFU)</p>
<p><strong>Abstract</strong>: Plotly is an open-source visualization library for creating interactive, publication-quality graphs in Python (and other languages), with support for a wide range of plot types. In this workshop, you will learn two ways to use Plotly: the high-level Plotly Express interface for rapid data exploration, and the more flexible Plotly Graph Objects interface for detailed customization. We will explore common plot types – line, scatter, bar, pie, and heatmap – as well as more advanced and 3D visualizations. You will learn how to display figures using different rendering backends, save them as image or HTML files, and view them inside Jupyter notebooks. Finally, we will take a look at Plotly Dash, a framework for building interactive data web applications with sliders, buttons, dropdown menus and other interactive elements.</p>
<p><strong>Prerequisites</strong>: Some knowledge of Python.</p>
<p><a href="plotly" target="_blank">Online notes</a></p>
</div>
</details>
<details>
<summary>
<strong>Feb-03, 10am PT – <span style="font-size: 1.2em;">Plotting in Python with Vega-Altair (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Pier-Luc St-Onge (McGill Univ.)</p>
<p><strong>Abstract</strong>: How can you uncover the hidden trends in your thousands of data rows? This workshop teaches you how to create interactive charts from your tabular data. You’ll master histograms, time series plots, distributions, and multi-faceted graphs to transform your tables into impactful visualizations.</p>
<p>Outline:</p>
<ul>
<li>Creating interactive charts with Altair</li>
<li>Building a figure step-by-step using a grammar of graphics</li>
<li>Visualizing time series and data distributions</li>
<li>Creating multiple facets in a single figure</li>
</ul>
<p><a href="https://docs.google.com/presentation/d/1GSXbIIiypHR9-8oQYi0ocablmAp9udsCGOVq4-RazaU" target="_blank">Slides</a>   <a href="https://github.com/calculquebec/dat203" target="_blank">GitHub repository</a></p>
</div>
</details>
<details>
<summary>
<strong>Feb-06, 10am PT – <span style="font-size: 1.2em;">Basic ParaView (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speakers</strong>: Alex Razoumov (SFU) and Pier-Luc St-Onge (McGill Univ.) and Tyson Whitehead (Western Univ.)</p>
<p><strong>Abstract</strong>: ParaView is an open source, multi-platform data analysis and visualization tool designed to run on a variety of hardware from individual laptops to large supercomputers. With ParaView, users can interactively visualize 2D and 3D datasets defined on structured, adaptive and unstructured meshes or particles, animate these datasets over time, and manipulate them with a variety of filters. ParaView supports both interactive visualization through a graphical user interface (GUI) and scripted visualization, including offscreen rendering, and is an easy and enjoyable tool to learn.</p>
<p>In this beginner’s workshop, we will explore ParaView’s interface, examine the types of data it can import, and learn how to use filters to build increasingly sophisticated visualization pipelines.</p>
<p><strong>Prerequisites</strong>: Please <a href="https://www.paraview.org/download" target="_blank">download and install ParaView</a> v6.0 on your computer, and test that you can start ParaView before the workshop. We will provide all sample datasets.</p>
<p><a href="https://calendar.google.com/calendar/u/0/r/eventedit/copy/dGJrdWk1MG83djl0ZXM0M2ljdjRnZXBmdmsgY185MzFlMWMwMzYxMmQzNGU5MzczMTQ0NTg4NzkxNDk2NGFjNGM0MDZmZDQ1YjNjNGUwMjRhZjczMjY0MzkxOTA2QGc" target="_blank">Add to your calendar</a>   <!-- [PDF slides](files/winterSeries/paraview-basic.pdf){target="_blank"} --> <!-- &emsp; --> <!-- [ZIP file with all ParaView slides and datasets](https://raw.githubusercontent.com/razoumov/publish/refs/heads/master/paraview.zip){target="_blank"} --></p>
</div>
</details>
<details>
<summary>
<strong>Feb-10, 10am PT – <span style="font-size: 1.2em;">The grammar of graphics in R and Python (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Tyson Whitehead (Western Univ.)</p>
<p><strong>Abstract</strong>: Most plotting packages offer a fixed set of built-in plot types to choose from. In contrast, the Grammar of Graphics defines a declarative framework for creating virtually unlimited visualizations by combining geometry, coordinate systems, facets, scales, guides, and themes. The most widely known implementation of this grammar is R’s ggplot2, with a lesser-known Python counterpart called Plotnine. This presentation introduces both libraries and demonstrates how the Grammar of Graphics can be used to build a wide range of plots.</p>
<!-- **Alex's Abstract**: Effective data visualization is more than just selecting a chart type; it is about -->
<!-- understanding the underlying structure of how data maps to visual elements. This workshop introduces the -->
<!-- Grammar of Graphics framework, a powerful abstraction for building complex, layered visualizations through a -->
<!-- consistent logic. Participants will explore how to implement these principles using the two most popular -->
<!-- libraries in the field: ggplot2 for R and Plotnine for Python. By focusing on the relationship between data -->
<!-- aesthetics, geometric layers, and statistical transformations, attendees will learn how to create flexible, -->
<!-- publication-quality graphics that are easy to iterate and customize. Whether you are coming from an R or -->
<!-- Python background, you will leave with a unified mental model for translating raw data into compelling visual -->
<!-- stories. -->
<p><a href="https://calendar.google.com/calendar/u/0/r/eventedit/copy/MGh2bzhlbTgxNmwzampxaWszaWRpOThwaTggY185MzFlMWMwMzYxMmQzNGU5MzczMTQ0NTg4NzkxNDk2NGFjNGM0MDZmZDQ1YjNjNGUwMjRhZjczMjY0MzkxOTA2QGc" target="_blank">Add to your calendar</a></p>
</div>
</details>
<details>
<summary>
<strong>Feb-13, 10am PT – <span style="font-size: 1.2em;">Introduction à ParaView (FR)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Pier-Luc St-Onge (McGill Univ.)</p>
<p><strong>Abstract</strong>: ParaView est un outil d’analyse et de visualisation de données à code source ouvert et multiplateforme, conçu pour fonctionner sur une variété de systèmes informatiques, des ordinateurs portatifs aux superordinateurs. Avec ParaView, on peut visualiser de manière interactive des ensembles de données 2D et 3D définis sur des particules ou des maillages structurés, adaptatifs ou non structurés. On peut ensuite animer ces données dans le temps et les manipuler à l’aide de divers filtres. ParaView prend en charge la visualisation interactive via une interface graphique, ainsi que la visualisation par script, y compris le rendu hors écran. C’est un outil facile et agréable à découvrir.</p>
<p>Dans cet atelier d’introduction, nous explorerons l’interface de ParaView, nous examinerons les types de données qu’il peut importer et nous apprendrons à utiliser des filtres pour construire des pipelines de visualisation de plus en plus sophistiqués.</p>
<p><a href="https://calendar.google.com/calendar/u/0/r/eventedit/copy/YTAzM2YxdWI0aGgxOXQyMmZodmFyODg2M2sgY185MzFlMWMwMzYxMmQzNGU5MzczMTQ0NTg4NzkxNDk2NGFjNGM0MDZmZDQ1YjNjNGUwMjRhZjczMjY0MzkxOTA2QGc" target="_blank">Add to your calendar</a></p>
</div>
</details>
<details>
<summary>
<strong>Feb-24, 10am PT – <span style="font-size: 1.2em;">ParaView scripting (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Alex Razoumov (SFU)</p>
<p><strong>Abstract</strong>: ParaView’s Python library allows you to automate your visualization workflow by scripting your tasks and running them from the command line, either on your local machine or as a batch Slurm job on a remote HPC cluster, all without opening any windows. In this workshop, we will introduce ParaView’s Python tools, starting with using the Trace feature to convert GUI actions into scripts and then showing how to simplify and modify those scripts. You will learn how to run them using pvpython and pvbatch, and how to explore VTK data from the ParaView Python shell.</p>
<p><strong>Prerequisites</strong>: basic ParaView knowledge (importing and examining data, working with filters). To participate in the hands-on exercises, please install ParaView on your computer. You can download it from the <a href="https://www.paraview.org/download" target="_blank">official website</a>.</p>
<p><a href="https://calendar.google.com/calendar/u/0/r/eventedit/copy/b3A3czVqYWVxYmdob25zaDE4a3VncG91YXMgY185MzFlMWMwMzYxMmQzNGU5MzczMTQ0NTg4NzkxNDk2NGFjNGM0MDZmZDQ1YjNjNGUwMjRhZjczMjY0MzkxOTA2QGc" target="_blank">Add to your calendar</a></p>
</div>
</details>
<details>
<summary>
<strong>Feb-27, 10am PT – <span style="font-size: 1.2em;">Scripter des visualisations via ParaView (FR)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Pier-Luc St-Onge (McGill Univ.)</p>
<p><strong>Abstract</strong>: La bibliothèque Python de ParaView vous permet d’automatiser votre processus de visualisation en programmant des séquences d’actions sous la forme de scripts et en les exécutant en ligne de commande, soit localement, soit via une tâche de calcul sur un superordinateur, le tout sans ouvrir aucune fenêtre de ParaView.</p>
<p>Cet atelier vous présentera les outils Python de ParaView, en commençant par l’utilisation de la fonction Trace pour convertir les actions de l’interface graphique en scripts, puis en vous montrant comment simplifier et modifier ces scripts. Vous apprendrez à les exécuter avec pvpython et pvbatch, et à explorer les données VTK depuis l’interpréteur Python de ParaView.</p>
<p><strong>Prérequis</strong>: connaissances de base de ParaView (importer et examiner des données, utiliser des filtres) et en programmation Python</p>
<p><a href="https://calendar.google.com/calendar/u/0/r/eventedit/copy/amZzM3AxZW1kdDhicWZvNW1xMHRlcWRyaWcgY185MzFlMWMwMzYxMmQzNGU5MzczMTQ0NTg4NzkxNDk2NGFjNGM0MDZmZDQ1YjNjNGUwMjRhZjczMjY0MzkxOTA2QGc" target="_blank">Add to your calendar</a></p>
</div>
</details>
<details>
<summary>
<strong>Mar-03, 10am PT – <span style="font-size: 1.2em;">ParaView animation (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Alex Razoumov (SFU)</p>
<p><strong>Abstract</strong>: ParaView supports several approaches to animating data. In this session, we will focus on keyframe animation, where you can animate any property of any pipeline object, e.g.&nbsp;moving a slice through a volume by changing its origin, or animating a 2D contour through a 3D dataset by varying the contour value. We will also look at how to combine multiple timelines within a single animation. After that, we’ll work through several hands-on keyframe animation exercises and discuss how to create animations using Python scripting.</p>
<p><strong>Prerequisites</strong>: To participate in the hands-on exercises, please install ParaView on your computer. You can download it from the <a href="https://www.paraview.org/download" target="_blank">official website</a>. Familiarity with ParaView basics – creating a visualization pipeline, applying filters, and scripting – is assumed and covered in earlier sessions.</p>
<p><a href="https://calendar.google.com/calendar/u/0/r/eventedit/copy/M3B1MGRlamNxM2liZjk4NjduZm5vYm5qajQgY185MzFlMWMwMzYxMmQzNGU5MzczMTQ0NTg4NzkxNDk2NGFjNGM0MDZmZDQ1YjNjNGUwMjRhZjczMjY0MzkxOTA2QGc" target="_blank">Add to your calendar</a></p>
</div>
</details>
<details>
<summary>
<strong>Mar-06, 10am PT – <span style="font-size: 1.2em;">Visualisations animées avec ParaView (FR)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Pier-Luc St-Onge (McGill Univ.)</p>
<p><strong>Abstract</strong>: ParaView permet d’animer de différentes façons la visualisation de données. Cet atelier sera consacré à l’animation par images clés, soit une méthode permettant d’animer selon n’importe quelle propriété d’un objet du pipeline. Nous verrons, entre autres, comment animer le plan de coupe d’un volume et aussi comment animer un contour 2D, selon sa valeur, dans un jeu de données 3D. Nous verrons également comment combiner plusieurs chronologies au sein d’une même animation. Enfin, nous réaliserons plusieurs exercices pratiques d’animation par images clés et aborderons la création d’animations à l’aide de scripts Python.</p>
<p><strong>Prérequis</strong>: connaissances de base de ParaView (importer et examiner des données, utiliser des filtres) et la compréhension de scripts Python utilisant le module ParaView.</p>
<p><a href="https://calendar.google.com/calendar/u/0/r/eventedit/copy/c3M5MHBmdDU4NTRwMGl2cHVtdjduMWZyMjAgY185MzFlMWMwMzYxMmQzNGU5MzczMTQ0NTg4NzkxNDk2NGFjNGM0MDZmZDQ1YjNjNGUwMjRhZjczMjY0MzkxOTA2QGc" target="_blank">Add to your calendar</a></p>
</div>
</details>
<details>
<summary>
<strong>Mar-10, 10am PT – <span style="font-size: 1.2em;">Remote and large-scale visualization in ParaView (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Alex Razoumov (SFU)</p>
<p><strong>Abstract</strong>: In this more advanced session, you will learn how to perform remote and large-scale visualization on the Alliance’s HPC clusters, for cases where you do not want to – or simply cannot – download the dataset to your local computer.</p>
<p>Small-scale remote visualization can be accomplished using JupyterHub or Open OnDemand, running either standalone ParaView or a ParaView client within a remote desktop environment.</p>
<p>For larger-scale interactive visualization, we will run a parallel ParaView server for data processing and rendering on a cluster and connect to it from a ParaView client on your local computer. This setup enables interactive visualization of very large datasets (multi-GB and potentially TB-scale) without transferring data locally, and without being limited by your own system’s memory or CPU/GPU resources.</p>
<p>We will explore workflows involving both time and camera animation. We will then save the interactive visualization pipeline as a script and run it remotely as a batch job on the cluster, performing all rendering off-screen (without opening any windows) to generate animation files.</p>
<p>Finally, we will discuss strategies for optimizing data for parallel I/O and the compute resources required to process very large datasets.</p>
<p><strong>Prerequisites</strong>: To participate in the hands-on exercises, please install ParaView on your computer. You can download it from the <a href="https://www.paraview.org/download" target="_blank">official website</a>. Familiarity with ParaView basics – creating a visualization pipeline, applying filters, and scripting – is assumed and covered in earlier sessions.</p>
<p><a href="https://calendar.google.com/calendar/u/0/r/eventedit/copy/NzV0bXY3dDFsYXVyYzJtbmFvN2o2MnVhNWMgY185MzFlMWMwMzYxMmQzNGU5MzczMTQ0NTg4NzkxNDk2NGFjNGM0MDZmZDQ1YjNjNGUwMjRhZjczMjY0MzkxOTA2QGc" target="_blank">Add to your calendar</a></p>
</div>
</details>
<details>
<summary>
<strong>Mar-13, 10am PT – <span style="font-size: 1.2em;">Introductory VMD (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Dmitri Rozmanov (Univ. of Calgary)</p>
<p><strong>Abstract</strong>: Visual Molecular Dynamics (VMD) is a dedicated tool for visualizing, analyzing, and animating molecular structures such as proteins, nucleic acids, and membranes, that is often used to post-process molecular dynamics simulations. In this hands-on workshop, attendees will learn to navigate the VMD interface, apply diverse molecular representations, and utilize VMD’s selection language to isolate key residues or ligands. The session will also cover loading molecular dynamics trajectories and generating high-quality renderings suitable for publication. By the end of this workshop, participants will have the fundamental skills to transform raw atomic data into meaningful visual insights.</p>
<p><a href="https://calendar.google.com/calendar/u/0/r/eventedit/copy/a3B0cTBybTk0NDl1bmVrdXRjaGY4a2FlcGMgY185MzFlMWMwMzYxMmQzNGU5MzczMTQ0NTg4NzkxNDk2NGFjNGM0MDZmZDQ1YjNjNGUwMjRhZjczMjY0MzkxOTA2QGc" target="_blank">Add to your calendar</a></p>
</div>
</details>
<details>
<summary>
<strong>Mar-17, 10am PT – <span style="font-size: 1.2em;">Programmable Filter / Source in ParaView (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Alex Razoumov (SFU)</p>
<p><strong>Abstract</strong>: ParaView includes two highly flexible scripting tools – the Programmable Filter and Programmable Source – that allow you to design your own data-processing operations. With them, you can construct entirely new spatial discretizations, generate tailored 3D structures, or even import data stored in custom file formats. This hands-on session will demonstrate how these features open up new possibilities for scientific visualization workflows.</p>
<p><strong>Prerequisites</strong>: To participate in the hands-on exercises, please install ParaView on your computer. You can download it from the <a href="https://www.paraview.org/download" target="_blank">official website</a>. Familiarity with ParaView basics – creating a visualization pipeline, applying filters, and scripting – is assumed and covered in earlier sessions.</p>
<p><a href="https://calendar.google.com/calendar/u/0/r/eventedit/copy/cmhrdjMxOXMzb3JiaW9lbTdvcTdkOXBnbTAgY185MzFlMWMwMzYxMmQzNGU5MzczMTQ0NTg4NzkxNDk2NGFjNGM0MDZmZDQ1YjNjNGUwMjRhZjczMjY0MzkxOTA2QGc" target="_blank">Add to your calendar</a></p>
</div>
</details>
<details>
<summary>
<strong>Mar-20, 10am PT – <span style="font-size: 1.2em;">Network visualization with Gephi (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speakers</strong>: Jarno van der Kolk (Univ. of Ottawa)</p>
<p><strong>Abstract</strong>: Gephi is an open-source platform for visualizing and manipulating large graphs. It lets you visualize how different entities connect with each other. These could be social media networks, researchers publishing papers, internet traffic and so on. It also has robust statistical analysis built-in.</p>
<p><strong>Prerequisites</strong>: Have Gephi installed. Downloads are available at <a href="https://gephi.org" target="_blank">https://gephi.org</a>.</p>
<p><a href="https://calendar.google.com/calendar/u/0/r/eventedit/copy/MGRwc3Q2cGRoM2EzNmc5YjBzaDdsdW44a3MgY185MzFlMWMwMzYxMmQzNGU5MzczMTQ0NTg4NzkxNDk2NGFjNGM0MDZmZDQ1YjNjNGUwMjRhZjczMjY0MzkxOTA2QGc" target="_blank">Add to your calendar</a></p>
</div>
</details>
<details>
<summary>
<strong>Mar-24, 10am PT – <span style="font-size: 1.2em;">In-situ visualization with ParaView’s Catalyst2 (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Alex Razoumov (SFU)</p>
<p><strong>Abstract</strong>: As numerical simulations continue to grow in size and complexity, the I/O bottleneck makes it impossible to save all generated data for later analysis. In-situ techniques address this challenge by running analysis and visualization in real time, while the data are still in memory on the HPC system running the simulation, eliminating the need to write everything to disk. Several in-situ visualization frameworks exist, including ParaView’s Catalyst, VisIt’s LibSim, Ascent, and SENSEI.</p>
<p>In this hands-on workshop, we will focus on Catalyst2, which allows you to analyze and visualize your simulation data using familiar ParaView pipelines. Catalyst2 provides an API for describing and passing data arrays – computational meshes and fields – from your simulation to the library, which then converts these arrays into the appropriate VTK data structures. This happens without requiring the user to understand the underlying VTK data model and without duplicating data in memory. This framework is designed to scale to very large datasets and to thousands of CPU cores via MPI.</p>
<p>The goal of this workshop is to instrument a simple C code with the Catalyst2 library and produce in-situ outputs, including data extracts and rendered images, using ParaView’s Python scripting.</p>
<p><strong>Prerequisites</strong>: To participate in the hands-on exercises, please install ParaView on your computer. You can download it from the <a href="https://www.paraview.org/download" target="_blank">official website</a>. Familiarity with ParaView basics – creating a visualization pipeline, applying filters, and scripting – is assumed and covered in earlier sessions. Some knowledge of C would be helpful, but we’ll take things step by step.</p>
<p><a href="https://calendar.google.com/calendar/u/0/r/eventedit/copy/M2pibDBoZzdhMDliZTV2dmJsMzlvcWpwb28gY185MzFlMWMwMzYxMmQzNGU5MzczMTQ0NTg4NzkxNDk2NGFjNGM0MDZmZDQ1YjNjNGUwMjRhZjczMjY0MzkxOTA2QGc" target="_blank">Add to your calendar</a></p>
</div>
</details>
<details>
<summary>
<strong>Mar-27, 10am PT – <span style="font-size: 1.2em;">Modern tools for web visualization (EN)</span></strong>
</summary>
<div style="padding:0.6rem 0;">
<p><strong>Speaker</strong>: Alex Razoumov (SFU)</p>
<p><strong>Abstract</strong>: We will begin with a brief overview of the history of general-purpose multidimensional web visualization, including the development of vtk.js and ParaViewWeb. The main focus of this hands-on workshop, however, is to teach you how to use Trame, an open-source framework for building interactive web applications and dashboards for data visualization. Trame leverages Python and popular visualization tools such as VTK and ParaView, and it offers plugins for many other Python plotting libraries.</p>
<p>In this session, we will introduce Trame’s core concepts, demonstrate how to create simple interactive visualizations, and show how to put them online for easy sharing. This workshop is ideal for researchers and data scientists who want to turn their static visualizations into interactive, shareable experiences without needing extensive web development expertise.</p>
<p><a href="https://calendar.google.com/calendar/u/0/r/eventedit/copy/ZDc5MzQ2anRrMzJlYWN1Z2FlNTl2dGdvbTQgY185MzFlMWMwMzYxMmQzNGU5MzczMTQ0NTg4NzkxNDk2NGFjNGM0MDZmZDQ1YjNjNGUwMjRhZjczMjY0MzkxOTA2QGc" target="_blank">Add to your calendar</a></p>
</div>
</details>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/folio\.vastcloud\.org");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>