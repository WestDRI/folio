<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Part 2: distributed computing with Ray – Various courses</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-a986a95301e671fce2c6472dffc862a1.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#initializing-ray" id="toc-initializing-ray" class="nav-link active" data-scroll-target="#initializing-ray">Initializing Ray</a></li>
  <li><a href="#ray-tasks" id="toc-ray-tasks" class="nav-link" data-scroll-target="#ray-tasks">Ray tasks</a>
  <ul class="collapse">
  <li><a href="#task-output" id="toc-task-output" class="nav-link" data-scroll-target="#task-output">Task output</a></li>
  <li><a href="#distributed-progress-bars" id="toc-distributed-progress-bars" class="nav-link" data-scroll-target="#distributed-progress-bars">Distributed progress bars</a></li>
  <li><a href="#parallelizing-the-slow-series-with-ray-tasks" id="toc-parallelizing-the-slow-series-with-ray-tasks" class="nav-link" data-scroll-target="#parallelizing-the-slow-series-with-ray-tasks">Parallelizing the slow series with Ray tasks</a></li>
  <li><a href="#running-numba-compiled-functions-as-ray-tasks" id="toc-running-numba-compiled-functions-as-ray-tasks" class="nav-link" data-scroll-target="#running-numba-compiled-functions-as-ray-tasks">Running Numba-compiled functions as Ray tasks</a></li>
  <li><a href="#getting-partial-results-from-ray-tasks" id="toc-getting-partial-results-from-ray-tasks" class="nav-link" data-scroll-target="#getting-partial-results-from-ray-tasks">Getting partial results from Ray tasks</a></li>
  <li><a href="#multiple-returns-from-ray-tasks" id="toc-multiple-returns-from-ray-tasks" class="nav-link" data-scroll-target="#multiple-returns-from-ray-tasks">Multiple returns from Ray tasks</a></li>
  <li><a href="#linking-remote-tasks" id="toc-linking-remote-tasks" class="nav-link" data-scroll-target="#linking-remote-tasks">Linking remote tasks</a></li>
  <li><a href="#persistent-storage-on-ray-workers" id="toc-persistent-storage-on-ray-workers" class="nav-link" data-scroll-target="#persistent-storage-on-ray-workers">Persistent storage on Ray workers</a></li>
  </ul></li>
  <li><a href="#ray-data" id="toc-ray-data" class="nav-link" data-scroll-target="#ray-data">Ray Data</a>
  <ul class="collapse">
  <li><a href="#creating-datasets" id="toc-creating-datasets" class="nav-link" data-scroll-target="#creating-datasets">Creating datasets</a></li>
  <li><a href="#transforming-datasets" id="toc-transforming-datasets" class="nav-link" data-scroll-target="#transforming-datasets">Transforming datasets</a></li>
  <li><a href="#vectorizable-dataset-transformations" id="toc-vectorizable-dataset-transformations" class="nav-link" data-scroll-target="#vectorizable-dataset-transformations">Vectorizable dataset transformations</a></li>
  <li><a href="#slow-series-with-ray-data" id="toc-slow-series-with-ray-data" class="nav-link" data-scroll-target="#slow-series-with-ray-data">Slow series with Ray Data</a></li>
  <li><a href="#processing-ray-datasets-with-numba-compiled-functions" id="toc-processing-ray-datasets-with-numba-compiled-functions" class="nav-link" data-scroll-target="#processing-ray-datasets-with-numba-compiled-functions">Processing Ray datasets with Numba-compiled functions</a></li>
  </ul></li>
  <li><a href="#running-ray-workflows-on-a-single-node" id="toc-running-ray-workflows-on-a-single-node" class="nav-link" data-scroll-target="#running-ray-workflows-on-a-single-node">Running Ray workflows on a single node</a></li>
  <li><a href="#running-ray-workflows-on-multiple-nodes" id="toc-running-ray-workflows-on-multiple-nodes" class="nav-link" data-scroll-target="#running-ray-workflows-on-multiple-nodes">Running Ray workflows on multiple nodes</a></li>
  <li><a href="#distributed-data-processing-on-ray-and-io-bound-workflows" id="toc-distributed-data-processing-on-ray-and-io-bound-workflows" class="nav-link" data-scroll-target="#distributed-data-processing-on-ray-and-io-bound-workflows">Distributed data processing on Ray and I/O-bound workflows</a>
  <ul class="collapse">
  <li><a href="#simple-distributed-dataset-example" id="toc-simple-distributed-dataset-example" class="nav-link" data-scroll-target="#simple-distributed-dataset-example">Simple distributed dataset example</a></li>
  <li><a href="#pandas-on-ray-modin" id="toc-pandas-on-ray-modin" class="nav-link" data-scroll-target="#pandas-on-ray-modin">Pandas on Ray (Modin)</a></li>
  <li><a href="#processing-images" id="toc-processing-images" class="nav-link" data-scroll-target="#processing-images">Processing images</a></li>
  <li><a href="#coding-parallel-io-by-hand" id="toc-coding-parallel-io-by-hand" class="nav-link" data-scroll-target="#coding-parallel-io-by-hand">Coding parallel I/O by hand</a></li>
  <li><a href="#a-cpu-intensive-problem-without-reduction" id="toc-a-cpu-intensive-problem-without-reduction" class="nav-link" data-scroll-target="#a-cpu-intensive-problem-without-reduction">A CPU-intensive problem without reduction</a></li>
  </ul></li>
  <li><a href="#quickly-on-parallel-python-in-ml-frameworks-marie" id="toc-quickly-on-parallel-python-in-ml-frameworks-marie" class="nav-link" data-scroll-target="#quickly-on-parallel-python-in-ml-frameworks-marie">Quickly on parallel Python in ML frameworks (Marie)</a>
  <ul class="collapse">
  <li><a href="#jax" id="toc-jax" class="nav-link" data-scroll-target="#jax">JAX</a></li>
  <li><a href="#pytorch" id="toc-pytorch" class="nav-link" data-scroll-target="#pytorch">PyTorch</a></li>
  <li><a href="#tensorflow" id="toc-tensorflow" class="nav-link" data-scroll-target="#tensorflow">TensorFlow</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Part 2: distributed computing with Ray</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- +++ -->
<!-- title = "" -->
<!-- slug = "ray" -->
<!-- katex = true -->
<!-- +++ -->
<!-- {{<cor>}}June 13<sup>th</sup>{{</cor>}}\ -->
<!-- {{<cgr>}}9:30am–12:30pm and 1:30pm-4:30pm Pacific Time{{</cgr>}} -->
<p>There is a number of high-level open-source parallel frameworks for Python that are quite popular in data science and beyond:</p>
<ul>
<li><a href="https://www.ray.io" target="_blank">Ray</a> is a unified framework for scaling AI and Python applications.</li>
<li><a href="https://www.dask.org" target="_blank">Dask</a> parallelizes Python loops and graphs of functions, scales NumPy, pandas, and scikit-learn.</li>
<li><a href="https://spark.apache.org/docs/latest/api/python" target="_blank">PySpark</a> is the Python API for Apache Spark for large-scale data processing in a distributed environment.</li>
<li><a href="https://mars-project.readthedocs.io" target="_blank">Mars</a> is a tensor-based unified framework for large-scale data computation which scales NumPy, pandas, scikit-learn and many other libraries.</li>
<li><a href="https://mpi4py.readthedocs.io" target="_blank">mpi4py</a> is the most popular Message Passing Interface (MPI) implementation for Python.</li>
<li><a href="https://ipyparallel.readthedocs.io" target="_blank">IPyParallel</a> architecture for parallel and distributed computing.</li>
<li><a href="https://joblib.readthedocs.io/en/latest/parallel.html" target="_blank">Joblib</a> for parallel for loops with multiprocessing.</li>
</ul>
<p>Here we’ll focus on Ray, a unified framework for scaling AI and general Python workflows. Since this is not a machine learning workshop, we will not touch Ray’s AI capabilities, but will focus on its core distributed runtime and data libraries. We will learn several different approaches to parallelizing purely numerical (and therefore CPU-bound) workflows, both with and without reduction. We will also look at I/O-bound workflows.</p>
<section id="initializing-ray" class="level2">
<h2 class="anchored" data-anchor-id="initializing-ray">Initializing Ray</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>ray.init()   <span class="co"># start a Ray cluster  and connect to it</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>             <span class="co"># no longer necessary, will run by default when you first use it</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>However, <code>ray.init()</code> is very useful for passing options at initialization. For example, Ray is quite verbose when you do things in it. To turn off this logging output to the terminal, you can do</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>ray.init(configure_logging<span class="op">=</span><span class="va">False</span>)   <span class="co"># hide Ray's copious logging output</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You can run <code>ray.init()</code> only once. If you want to re-run it, first you need to run <code>ray.shutdown()</code>. Alternatively, you can pass the argument <code>ignore_reinit_error=True</code> to the call.</p>
<p>You can specify the number of cores for Ray to use, and you can combine multiple options, e.g.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">4</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>By default Ray will use all available CPU cores, e.g.&nbsp;on my laptop <code>ray.init()</code> will start 8 ray::IDLE processes (workers), and you can monitor these in a separate shell with <code>htop --filter "ray::IDLE"</code> command (you may want to hide threads – typically thrown in green – with Shift+H).</p>
<blockquote class="blockquote">
<h3 id="discussion" class="anchored">Discussion</h3>
<p>How many “ray::IDLE” processes do you see, and why? Recall that you can use <code>srun --jobid=&lt;jobID&gt; --pty bash</code> to open an interactive shell process inside your currently running job, and run <code>htop --filter "ray::IDLE"</code> there.</p>
</blockquote>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Question 11
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>How would you pass the actual number of processor cores to the Ray cluster? Consider three options:<br>
1. Using a Slurm environment variable. How would you pass it to <code>ray.init()</code>?<br>
2. Launching a single-node Ray cluster as described in our <a href="https://docs.alliancecan.ca/wiki/Ray">Ray documentation</a>.<br>
3. Not passing anything at all, in which case Ray will try – unsuccessfully – to grab all cores.</p>
</div>
</div>
</div>
</section>
<section id="ray-tasks" class="level2">
<h2 class="anchored" data-anchor-id="ray-tasks">Ray tasks</h2>
<p>In Ray you can execute any Python function asynchronously on separate workers. Such functions are called <strong>Ray remote functions</strong>, and their asynchronous invocations are called <strong>Ray tasks</strong>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>ray.init(configure_logging<span class="op">=</span><span class="va">False</span>)   <span class="co"># optional</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span>             <span class="co"># declare that we want to run this function remotely</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> square(x):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> x</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> square.remote(<span class="dv">10</span>)   <span class="co"># launch/schedule a remote calculation (non-blocking call)</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(r)                 <span class="co"># ray._raylet.ObjectRef (object reference)</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>ray.get(r)              <span class="co"># retrieve the result (=100) (blocking call)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The calculation may happen any time between <code>&lt;function&gt;.remote()</code> and <code>ray.get()</code> calls, i.e.&nbsp;it does not necessarily start when you launch it. This is called <strong>lazy execution</strong>: the operation is often executed when you try to access the result.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> square.remote(<span class="dv">10</span>)   <span class="co"># launch a remote calculation</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>ray.cancel(a)           <span class="co"># cancel it</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>ray.get(a)              <span class="co"># either error or 100, depending on whether the calculation</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># has finished before cancellation</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You can launch several Ray tasks at once, to be executed in parallel in the background, and you can retrieve their results either individually or through the list:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> [square.remote(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>)]   <span class="co"># launch four parallel tasks (non-blocking call)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>([ray.get(r[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>)])   <span class="co"># retrieve the results (multiple blocking calls)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(r))          <span class="co"># more compact way to do the same (single blocking call)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="task-output" class="level3">
<h3 class="anchored" data-anchor-id="task-output">Task output</h3>
<p>Consider a code in which each Ray task sleeps for 10 seconds, prints a message and returns its task ID:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> sleep, time</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">4</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nap():</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    sleep(<span class="dv">10</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"almost done"</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ray.get_runtime_context().get_task_id()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s run it with timing on:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> [nap.remote() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>)]</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>ray.get(r)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>I get 10.013 seconds since I have enough cores to run all of them in parallel. However, most likely, I see printout (“almost done”) from only one process and a message “repeated 3x across cluster”. To enable print messages from all tasks, you need set the bash shell environment variable <code>export RAY_DEDUP_LOGS=0</code>.</p>
<p>Notice that Ray task IDs are not integers but 48-character hexadecimal numbers.</p>
</section>
<section id="distributed-progress-bars" class="level3">
<h3 class="anchored" data-anchor-id="distributed-progress-bars">Distributed progress bars</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ray.experimental.tqdm_ray <span class="im">import</span> tqdm</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> busy(name):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">"2"</span> <span class="kw">in</span> name: sleep(<span class="dv">2</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> tqdm(<span class="bu">range</span>(<span class="dv">100</span>), desc<span class="op">=</span>name):</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        sleep(<span class="fl">0.1</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>[busy.remote(<span class="st">"task 1"</span>), busy.remote(<span class="st">"task 2"</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>A side effect of <code>tqdm()</code> is that these tasks start running immediately.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Question 11b
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Implement the same for 10 tasks using a <code>for</code> loop.</p>
</div>
</div>
</div>
<!-- Solution: -->
<!-- ```py -->
<!-- [busy.remote("task "+str(i)) for i in range(10)] -->
<!-- ``` -->
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ray’s <code>tqdm()</code> is somewhat buggy, so you might want to restart Python and your Ray cluster, if you don’t want to see artifacts from previous bars sometimes popping up in your session.</p>
</div>
</div>
<!-- ### Task monitoring -->
<!-- Ray provides a command-line utility to monitor current and past tasks in bash, while a Ray instance is -->
<!-- running. On your own computer you would do: -->
<!-- ```sh -->
<!-- pyenv activate hpc-env -->
<!-- ray summary tasks -->
<!-- ``` -->
</section>
<section id="parallelizing-the-slow-series-with-ray-tasks" class="level3">
<h3 class="anchored" data-anchor-id="parallelizing-the-slow-series-with-ray-tasks">Parallelizing the slow series with Ray tasks</h3>
<p>Let’s perform our slow series calculation as a Ray task. This is our original serial implementation, now with a Ray remote function running on one of the workers:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">4</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> slow(n: <span class="bu">int</span>):</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="st">"9"</span> <span class="kw">in</span> <span class="bu">str</span>(i):</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> <span class="fl">1.0</span> <span class="op">/</span> i</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> slow.remote(<span class="dv">100_000_000</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> ray.get(r)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We should get the same timing as before (~6-7 seconds). You can call <code>ray.get()</code> on the previously computed result again without having to redo the calculation:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>tmp <span class="op">=</span> ray.get(r)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))   <span class="co"># 0.001 seconds</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tmp)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s speed up this calculation with parallel Ray tasks! Instead of doing the full sum over <code>range(1,n+1)</code>, let’s calculate a partial sum on each task:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> psutil, ray</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">4</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> slow(interval):</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(interval[<span class="dv">0</span>],interval[<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="st">"9"</span> <span class="kw">in</span> <span class="bu">str</span>(i):</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> <span class="fl">1.0</span> <span class="op">/</span> i</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This would be a serial calculation:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100_000_000</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> slow.remote((<span class="dv">1</span>, n))   <span class="co"># takes in one argument</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> ray.get(r)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To launch it in parallel, we need to subdivide the interval:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>ncores <span class="op">=</span> psutil.cpu_count(logical<span class="op">=</span><span class="va">False</span>)   <span class="co"># good option on a standalone computer</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>ncores <span class="op">=</span> <span class="dv">4</span>                                 <span class="co"># on a cluster</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>size <span class="op">=</span> n<span class="op">//</span>ncores   <span class="co"># size of each batch</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>intervals <span class="op">=</span> [(i<span class="op">*</span>size<span class="op">+</span><span class="dv">1</span>,(i<span class="op">+</span><span class="dv">1</span>)<span class="op">*</span>size) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncores)]</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> n <span class="op">&gt;</span> intervals[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>]: intervals[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (intervals[<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>], n)   <span class="co"># add the remainder (if any)</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> [slow.remote(intervals[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncores)]</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="bu">sum</span>(ray.get(r))   <span class="co"># compute total sum</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>On 8 cores I get the average runtime of 1.282 seconds – not too bad, considering that some of the cores are low-efficiency (slower) cores.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Question 12
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Increase <code>n</code> to 1_000_000_000 and run <code>htop --filter "ray::IDLE</code> in a separate shell to monitor CPU usage of individual processes.</p>
</div>
</div>
</div>
</section>
<section id="running-numba-compiled-functions-as-ray-tasks" class="level3">
<h3 class="anchored" data-anchor-id="running-numba-compiled-functions-as-ray-tasks">Running Numba-compiled functions as Ray tasks</h3>
<p>We ended Part 1 with a Numba-compiled version of the slow series code that works almost as well as a Julia/Chapel code. As you just saw, Ray itself can distribute the calculation, speeding up the code with parallel execution, but individual tasks still run native Python code that is slow.</p>
<p>Wouldn’t it be great if we could use Ray to distribute execution of Numba-compiled functions to workers? It turns out <em>we can</em>, but we have to be careful with syntax. We would need to define remote compiled functions, but neither Ray, nor Numba let you combine their decorators (<code>@ray.remote</code> and <code>@numba.jit</code>, respectively) for a single function. You can do this in two steps:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numba <span class="im">import</span> jit</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">4</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> square(x):</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">*</span>x</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> runCompiled():</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> square(<span class="dv">5</span>)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> runCompiled.remote()</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>ray.get(r)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here we “jit” the function on the main process and send it to workers for execution. Alternatively, you can “jit” on workers:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numba <span class="im">import</span> jit</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">4</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> square(x):</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">*</span>x</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> runCompiled():</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    compiledSquare <span class="op">=</span> jit(square)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> compiledSquare(<span class="dv">5</span>)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> runCompiled.remote()</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>ray.get(r)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In my tests with more CPU-intensive functions, both versions produce equivalent runtimes.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Question Combining Numba and Ray remotes for the slow series (big one!)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Write a slow series solver with Numba-compiled functions executed as Ray tasks. 1. Numba-compiled <code>combined(k)</code> that returns either 1/x or 0.<br>
2. Numba-compiled <code>slow(interval)</code> for partial sums.<br>
3. Ray-enabled remote function <code>runCompiled(interval)</code> to launch partial sums on workers.<br>
4. Very important step: you must do small <code>runCompiled()</code> runs on workers to copy code over to them – no need to time these runs. Without this “pre-compilation” step you will not get fast execution on workers on the bigger problem.<br>
5. The rest of the code will look familiar:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> [runCompiled.remote(intervals[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncores)]</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="bu">sum</span>(ray.get(r))   <span class="co"># compute total sum</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
<!-- Solution (on presenter's laptop in `slowSeriesNumbaRay.py`): -->
<!-- ```py -->
<!-- from time import time -->
<!-- import ray -->
<!-- from numba import jit -->
<!-- ray.init(configure_logging=False) -->
<!-- n = 100_000_000 -->
<!-- @jit(nopython=True) -->
<!-- def combined(x): -->
<!--     base, x0 = 10, x -->
<!--     while 9//base > 0: base *= 10 -->
<!--     while x > 0: -->
<!--         if x%base == 9: return 0.0 -->
<!--         x = x//10 -->
<!--     return 1.0/x0 -->
<!-- @jit(nopython=True) -->
<!-- def slow(interval): -->
<!--     total = 0 -->
<!--     for i in range(interval[0],interval[1]+1): -->
<!--         total += combined(i) -->
<!--     return total -->
<!-- @ray.remote -->
<!-- def runCompiled(interval): -->
<!--     return slow(interval) -->
<!-- ncores = 4 -->
<!-- size = n//ncores   # size of each batch -->
<!-- intervals = [(i*size+1,(i+1)*size) for i in range(ncores)] -->
<!-- if n > intervals[-1][1]: intervals[-1] = (intervals[-1][0], n)   # add the remainder (if any) -->
<!-- r = [runCompiled.remote((1,10)) for i in range(ncores)]   # expose workers to runCompiled function -->
<!-- total = sum(ray.get(r)) -->
<!-- start = time() -->
<!-- r = [runCompiled.remote(intervals[i]) for i in range(ncores)] -->
<!-- total = sum(ray.get(r))   # compute total sum -->
<!-- end = time() -->
<!-- print("Time in seconds:", round(end-start,3)) -->
<!-- print(total) -->
<!-- ``` -->
<p>Averaged (over three runs) times:</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td>ncores</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
</tr>
<tr class="even">
<td>wallclock runtime (sec)</td>
<td>0.439</td>
<td>0.235</td>
<td>0.130</td>
<td>0.098</td>
</tr>
</tbody>
</table>
<p>Using a combination of Numba and Ray tasks on 8 cores, we accelerated the calculation by ~68X.</p>
</section>
<section id="getting-partial-results-from-ray-tasks" class="level3">
<h3 class="anchored" data-anchor-id="getting-partial-results-from-ray-tasks">Getting partial results from Ray tasks</h3>
<p>Consider the following code:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> sleep</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray, random</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longSleep():</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    duration <span class="op">=</span> random.randint(<span class="dv">1</span>,<span class="dv">100</span>) <span class="co"># random integer from [1,100]</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    sleep(duration)   <span class="co"># sleep for this number of seconds</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ss">f"I slept for </span><span class="sc">{</span>duration<span class="sc">}</span><span class="ss"> seconds"</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>refs <span class="op">=</span> [longSleep.remote() <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">21</span>)]   <span class="co"># start 20 tasks</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If we now call <code>ray.get(refs)</code>, that would block until all of these remote tasks finish. If we want to, let’s say, one of them to finish and then continue on the main task, we can do:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>ready_refs, remaining_refs <span class="op">=</span> ray.wait(refs, num_returns<span class="op">=</span><span class="dv">1</span>, timeout<span class="op">=</span><span class="va">None</span>) <span class="co"># wait for one of them to finish</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ready_refs, remaining_refs)   <span class="co"># print the IDs of the finished task, and the other 19 IDs</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>ray.get(ready_refs)                 <span class="co"># get finished results</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s wait for the first 5 answers:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>ready_refs, remaining_refs <span class="op">=</span> ray.wait(refs, num_returns<span class="op">=</span><span class="dv">5</span>, timeout<span class="op">=</span><span class="va">None</span>) <span class="co"># wait for 5 of them to finish</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>ray.get(ready_refs)                 <span class="co"># get finished results</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> remaining_refs:</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    ray.cancel(i)   <span class="co"># cancel the unfinished ones</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="multiple-returns-from-ray-tasks" class="level3">
<h3 class="anchored" data-anchor-id="multiple-returns-from-ray-tasks">Multiple returns from Ray tasks</h3>
<p>Similar to normal Python functions, Ray tasks can return tuples:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> threeNumbers():</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> threeNumbers.remote()</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(r)[<span class="dv">0</span>])        <span class="co"># get the result (tuple) and show its first element</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Alternatively, you can pipe each number to a separate object ref (<em>tell the decorator!</em>):</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span>(num_returns<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> threeNumbers():</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>r1, r2, r3 <span class="op">=</span> threeNumbers.remote()</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>ray.get(r1)   <span class="co"># get the first result only</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You can also create a remote generator that will return only one number at a time, to reduce memory usage:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span>(num_returns<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> threeNumbers():</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):   <span class="co"># should return 10,20,30</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> (i<span class="op">+</span><span class="dv">1</span>)<span class="op">*</span><span class="dv">10</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>r1, r2, r3 <span class="op">=</span> threeNumbers.remote()</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>ray.get(r1)   <span class="co"># get the first number only</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="linking-remote-tasks" class="level3">
<h3 class="anchored" data-anchor-id="linking-remote-tasks">Linking remote tasks</h3>
<p>In addition to values, object refs can also be passed to remote functions. Define two functions:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> one():</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> increment(value):</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> value <span class="op">+</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In by-now familiar syntax:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>r1 <span class="op">=</span> one.remote()                    <span class="co"># create the first Ray task</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>r2 <span class="op">=</span> increment.remote(ray.get(r1))   <span class="co"># pass its result as an argument to another Ray task</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(r2))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You can also shorten this syntax:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>r1 <span class="op">=</span> one.remote()           <span class="co"># create the first Ray task</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>r2 <span class="op">=</span> increment.remote(r1)   <span class="co"># pass its object ref as an argument to another Ray task</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(r2))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As the second task depends on the output of the first task, Ray will not execute the second task until the first task has finished.</p>
<!-- ```py -->
<!-- # start = time() -->
<!-- # ray.get([nap.remote() for i in range(4)]) -->
<!-- # end = time() -->
<!-- # print("Time in seconds:", round(end-start,3))   #  -->
<!-- # my_function.options(num_cpus=3).remote() -->
<!-- # @ray.remote(num_cpus=2) -->
<!-- # def nap(): -->
<!-- #     sleep(10) -->
<!-- #     print("almost done") -->
<!-- #     return ray.get_runtime_context().get_task_id() -->
<!-- # start = time() -->
<!-- # ray.get([nap.remote() for i in range(4)]) -->
<!-- # end = time() -->
<!-- # print("Time in seconds:", round(end-start,3))   #  -->
<!-- ``` -->
</section>
<section id="persistent-storage-on-ray-workers" class="level3">
<h3 class="anchored" data-anchor-id="persistent-storage-on-ray-workers">Persistent storage on Ray workers</h3>
<!-- abc -->
<!-- from https://wgpages.netlify.app/clusterworkflows/#persistent-storage-on-ray-workers -->
<p>You might have noticed that Ray functions (remote tasks) are stateless, i.e.&nbsp;they can run on any processor that happens to be more idle at the time, and they <em>do not store any data on that processor</em> in between the function calls.</p>
<p>If you are trying to parallelize a tightly-coupled problem, you might want to store arrays on the workers permanently, and then repeatedly call quick functions to do some computations on these arrays, without copying the arrays back and forth at each step.</p>
<p>To do this in Ray, we can use <strong>Ray actors</strong> (https://docs.ray.io/en/latest/ray-core/actors.html). A Ray actor is essentially a stateful (bound to a processor) worker that is created via a Python class instance with its own persistent variables and methods, and it stays permanently on that worker until we destroy this instance.</p>
<!-- 1. persistent storage -->
<!-- 2. launch calculations on all processors simultaneously -->
<!-- In Ray, you can store an array on a worker between two function calls using actor-based state -->
<!-- management. Since Ray functions (remote tasks) are stateless by default, you need an actor to persist the -->
<!-- array across calls. -->
<div class="sourceCode" id="cb27"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>ray.init()</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ArrayStorage:         <span class="co"># define an actor (ArrayStorage class) with a persistent array</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.array <span class="op">=</span> <span class="va">None</span>   <span class="co"># persistent array variable</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> store_array(<span class="va">self</span>, arr):</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.array <span class="op">=</span> arr    <span class="co"># store an array in the actor's state</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_array(<span class="va">self</span>):</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.array   <span class="co"># retrieve the stored array</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>storage_actor <span class="op">=</span> ArrayStorage.remote()   <span class="co"># create an instance of the actor</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>])</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>ray.get(storage_actor.store_array.remote(arr))   <span class="co"># store an array</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> ray.get(storage_actor.get_array.remote())    <span class="co"># retrieve the stored array</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(r)  <span class="co"># Output: [1 2 3 4 5]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<!-- ```py -->
<!-- print(f"Actor {worker1_actor_id} on Node {worker1_node_id} stored array: {retrieved_arr1}") -->
<!-- print(f"Actor {worker2_actor_id} on Node {worker2_node_id} stored array: {retrieved_arr2}") -->
<!-- ``` -->
<p>To scale this to multiple workers, we can do the same with an array of workers:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>workers <span class="op">=</span> [ArrayStorage.remote() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>)]   <span class="co"># create two instances of the actor</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> [workers[i].store_array.remote(np.ones(<span class="dv">5</span>)<span class="op">*</span>(i<span class="op">+</span><span class="dv">1</span>)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>)]</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(r))</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(workers[<span class="dv">0</span>].get_array.remote()))   <span class="co"># [1. 1. 1. 1. 1.]</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(workers[<span class="dv">1</span>].get_array.remote()))   <span class="co"># [2. 2. 2. 2. 2.]</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> [workers[i].get_array.remote() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>)]</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(r))   <span class="co"># both arrays in one go</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If we want to make sure that these arrays stay on the same workers, we can retrieve and print their IDs and the node IDs by adding these two functions to the actor class:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_actor_id(<span class="va">self</span>):</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.actor_id</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_node_id(<span class="va">self</span>):</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.node_id   <span class="co"># the node ID where this actor is running</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>...</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>([ray.get(workers[i].get_actor_id.remote()) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>)])   <span class="co"># actor IDs</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>([ray.get(workers[i].get_node_id.remote()) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>)])    <span class="co"># node IDs</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<!-- Full class example: -->
<!-- ```py -->
<!-- @ray.remote -->
<!-- class ArrayStorage: -->
<!--     def __init__(self): -->
<!--         self.a = None   # persistent state -->
<!--         self.b = None   # persistent state -->
<!--         self.u = None   # persistent state -->
<!--         self.actor_id = ray.get_runtime_context().get_actor_id()  # get actor's unique ID -->
<!--         self.node_id = ray.get_runtime_context().get_node_id()    # get node ID -->
<!--     def init_a(self, n): -->
<!--         initial = np.identity(n).reshape([n*n]) -->
<!--         a = -2.0*initial -->
<!--         a[1:n*n-1] = a[1:n*n-1] + initial[:n*n-2] + initial[2:] -->
<!--         self.a = a.reshape([n,n]) -->
<!--     def store_b(self, arr):   # store an array in the actor's state -->
<!--         self.b = arr -->
<!--     def get_a(self): -->
<!--         return self.a -->
<!--     def get_u(self): -->
<!--         return self.u -->
<!--     def get_actor_id(self): -->
<!--         return self.actor_id -->
<!--     def get_node_id(self): -->
<!--         return self.node_id   # the node ID where this actor is running -->
<!--     def localSolve(self): -->
<!--         self.u = np.linalg.solve(self.a,self.b) -->
<!--     def getLastValue(self): -->
<!--         return self.u[-1] -->
<!--     def getFirstValue(self): -->
<!--         return self.u[0] -->
<!--     def updateLastB(self, ghostValue): -->
<!--         # self.b[-1] += ghostValue -->
<!--         self.b = np.concatenate([self.b[:-1], [self.b[-1]+ghostValue]]) -->
<!--     def updateFirstB(self, ghostValue): -->
<!--         # self.b[0] += ghostValue -->
<!--         self.b = np.concatenate([[self.b[0]+ghostValue], self.b[1:]]) -->
<!-- ``` -->
<p>You can even use NumPy on workers. For example, if we were to implement a linear algebra solver on a worker and <em>wanted to have the solution array stored there permanently</em>, we could do it this way:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">2</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.exp(<span class="op">-</span>(<span class="dv">100</span><span class="op">*</span>(np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,n)<span class="op">-</span><span class="fl">0.45</span>))<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>h<span class="op">*</span>h</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ArrayStorage:</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.b <span class="op">=</span> <span class="va">None</span>   <span class="co"># persistent variable</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.u <span class="op">=</span> <span class="va">None</span>   <span class="co"># persistent variable</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>        flatIdentity <span class="op">=</span> np.identity(n).reshape([n<span class="op">*</span>n])</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> <span class="op">-</span><span class="fl">2.0</span><span class="op">*</span>flatIdentity</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>        a[<span class="dv">1</span>:n<span class="op">*</span>n<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> a[<span class="dv">1</span>:n<span class="op">*</span>n<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> flatIdentity[:n<span class="op">*</span>n<span class="op">-</span><span class="dv">2</span>] <span class="op">+</span> flatIdentity[<span class="dv">2</span>:]</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.a <span class="op">=</span> a.reshape([n,n])   <span class="co"># persistent variable</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> store_b(<span class="va">self</span>, arr):</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.b <span class="op">=</span> arr                <span class="co"># store an array in the actor's state</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_u(<span class="va">self</span>):</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.u</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> localSolve(<span class="va">self</span>):</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.u <span class="op">=</span> np.linalg.solve(<span class="va">self</span>.a,<span class="va">self</span>.b)</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>worker <span class="op">=</span> ArrayStorage.remote(n)</span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>worker.store_b.remote(b)</span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>worker.localSolve.remote()</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> ray.get(worker.get_u.remote())</span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The solution is"</span>, u)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, you can delete a Ray actor with:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>ray.kill(worker)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Is it possible to use JIT-compiled functions inside a Ray actor? The answer is “probably yes”: in Numba there is an <a href="https://numba.pydata.org/numba-doc/dev/user/jitclass.html">experimental feature</a> to compile Python classes with <code>@jitclass</code>. Whether you can use it to compile Ray classes is an open question – I’d be very interested to hear your findings on this.</p>
</div>
</div>
</section>
</section>
<section id="ray-data" class="level2">
<h2 class="anchored" data-anchor-id="ray-data">Ray Data</h2>
<p>Ray Data is a parallel data processing library for ML workflows. As you will see in this section, Ray Data can be easily used for non-ML workflows. To process large datasets, Ray Data uses <strong>streaming/lazy execution</strong>, i.e.&nbsp;processing does not happen until you try to access (<em>“consume”</em> in Ray’s language) the result.</p>
<!-- https://www.anyscale.com/blog/streaming-distributed-execution-across-cpus-and-gpus -->
<p>The core object in Ray Data is a <strong>dataset</strong> which is a distributed data collection. Ray datasets can store general multidimensional array data that are too large to fit into a single machine’s memory. In Ray, these large arrays will be: 1. distributed in memory across a number of Ray tasks and 2. saved to disk once they are no longer in use.</p>
<p>Ray’s dataset operates over a sequence of Ray object references to blocks. Each block contains a disjoint subset of rows, and Ray Data loads and transforms these blocks in parallel. Each row in Ray’s datasets is a dictionary.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Recall: a Python dictionary is a collection of key-value pairs.</p>
</div>
</div>
<section id="creating-datasets" class="level3">
<h3 class="anchored" data-anchor-id="creating-datasets">Creating datasets</h3>
<div class="sourceCode" id="cb33"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">4</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> ray.data.<span class="bu">range</span>(<span class="dv">1000</span>)   <span class="co"># create a dataset from a range</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>ds                <span class="co"># Dataset(num_rows=1000, schema={id: int64})</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>ds.count()        <span class="co"># explicitly count the number of rows; might be expensive (to load the dataset into memory)</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>ds.take(<span class="dv">3</span>)        <span class="co"># return first 3 rows as a list of dictionaries; default keys are often 'id' or 'item'</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(ds.take())    <span class="co"># default is 20 rows</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>ds.show(<span class="dv">3</span>)        <span class="co"># first 3 rows in a different format (one row per line)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Until recently, you could easily displays the number of blocks in a dataset, but now you have to <em>materialize</em> it first, and the number of blocks can change during execution:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>ds.materialize().num_blocks()   <span class="co"># will show the number of blocks; might be expensive</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Rows can be generated from arbitrary items:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>ray.data.from_items([<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>]).take()   <span class="co"># [{'item': 10}, {'item': 20}, {'item': 30}]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Rows can have multiple key-value pairs:</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Recall: each row is a dictionary, and dictionaries can have multiple entries.</p>
</div>
</div>
<div class="sourceCode" id="cb36"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>listOfDict <span class="op">=</span> [{<span class="st">"col1"</span>: i, <span class="st">"col2"</span>: i <span class="op">**</span> <span class="dv">2</span>} <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1000</span>)] <span class="co"># each dict contains 2 pairs</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> ray.data.from_items(listOfDict)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>ds.show(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>A dataset can also be loaded from a file:</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>This example works on my computer (<code>pyenv activate hpc-env</code>), but not on the training cluster where <code>arrow/19.0.1</code> was compiled without S3 support.</p>
</div>
</div>
<div class="sourceCode" id="cb37"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>dd <span class="op">=</span> ray.data.read_csv(<span class="st">"s3://anonymous@air-example-data/iris.csv"</span>)   <span class="co"># load a predefined dataset</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>dd</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>dd.show()   <span class="co"># might pause to read data, default is 20 rows</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="transforming-datasets" class="level3">
<h3 class="anchored" data-anchor-id="transforming-datasets">Transforming datasets</h3>
<!-- operations: (1) transformation: takes in Dataset, outputs a new Dataset) -->
<!--             (2) consumption: produces values (not a data stream) as output (e.g. iter_batches()) -->
<!-- parallel processing at scale: (1) transformations, e.g. map_batches() -->
<!--                               (2) aggregations, e.g. min()/max()/mean() -->
<!--                               (3) grouping via groupby() -->
<!--                               (4) shuffling operations, e.g. sort(), random_shuffle(), and repartition() -->
<p>Ray datasets become useful once you start processing them. Let’s initialize a simple dataset from a range:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">4</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> ray.data.<span class="bu">range</span>(<span class="dv">1000</span>)   <span class="co"># create a dataset</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>ds.show(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We will apply a function to each row in this dataset. This function <em>must</em> return a dictionary that will form each row in the new dataset:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>ds.<span class="bu">map</span>(<span class="kw">lambda</span> row: row).show(<span class="dv">3</span>)                  <span class="co"># takes a row, returns the same row</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>ds.<span class="bu">map</span>(<span class="kw">lambda</span> row: {<span class="st">"key"</span>: row[<span class="st">"id"</span>]}).show(<span class="dv">3</span>)   <span class="co"># takes a row, returns a similar row;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>                       <span class="co"># `row["id"]` is needed to refer to the value in each</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>                       <span class="co"># original row; `key` is a new, arbitrary key name</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> ds.<span class="bu">map</span>(<span class="kw">lambda</span> row: {<span class="st">"long"</span>: <span class="bu">str</span>(row[<span class="st">"id"</span>])<span class="op">*</span><span class="dv">3</span>})  <span class="co"># takes a row, returns a dict with 'id' values</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>                                                    <span class="co"># converted to strings and repeated 3X</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>a   <span class="co"># it is a new dataset</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>a.show(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With <code>.map()</code> you can also use familiar non-lambda (i.e.&nbsp;non-anonymous) functions:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> squares(row):</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {<span class="st">'squares'</span>: row[<span class="st">'id'</span>]<span class="op">**</span><span class="dv">2</span>}</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>ds.<span class="bu">map</span>(squares).show(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Your function can also add new key-value pairs to the existing rows, instead of returning brand new rows:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> ray.data.<span class="bu">range</span>(<span class="dv">1000</span>)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> addSquares(row):</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    row[<span class="st">'square'</span>] <span class="op">=</span> row[<span class="st">'id'</span>]<span class="op">**</span><span class="dv">2</span>   <span class="co"># add a new entry to each row</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> row                       </span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> ds.<span class="bu">map</span>(addSquares)</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>ds.show(<span class="dv">5</span>)  <span class="co"># original dataset</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>b.show(<span class="dv">5</span>)   <span class="co"># contains both the original entries and the squares</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You might have already noticed by now that all processing in Ray Data is lazy, i.e.&nbsp;it happens when we request results:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> ray.data.<span class="bu">range</span>(<span class="dv">10_000_000</span>)   <span class="co"># define a bigger dataset</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>ds.<span class="bu">map</span>(addSquares)   <span class="co"># no visible calculation, just a request, not consuming results</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>ds.<span class="bu">map</span>(addSquares).show()   <span class="co"># print results =&gt; start calculation</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>ds.<span class="bu">map</span>(addSquares).show()   <span class="co"># previous results were not stored, so this will re-run the calculation</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> ds.<span class="bu">map</span>(addSquares)   <span class="co"># this does not start calculation</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>b.show()                 <span class="co"># this starts calculation</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Every time you print or use <code>b</code>, it’ll re-do the calculation. For this reason, you can think of <code>b</code> not as a variable with a value but as a <em>data stream</em>.</p>
<p>How can you do the calculation once and store the results for repeated use? You can convert <code>b</code> into a more permanent (not a data stream) object, e.g.&nbsp;a list:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> ds.<span class="bu">map</span>(addSquares)   <span class="co"># this does not start calculation</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> b.take()             <span class="co"># create a list, fast (only first 20 elements)</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> b.take(<span class="dv">10_000_000</span>)   <span class="co"># takes a couple of minutes, runs in parallel</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is not very efficient … certainly, computing 10,000,000 squares should not take a couple of minutes in parallel! The problem is that we have too many rows, and – similar to Python lists – <strong>Ray datasets perform poorly with too many rows</strong>. Think about subdividing your large computation into a number of chunks where each chunk comes with its own computational and communication overhead – you want to keep their number small.</p>
<p>Let’s rewrite this problem:</p>
<!-- ```py -->
<!-- n = 10_000_000 -->
<!-- a = np.arange(n) -->
<!-- start = time() -->
<!-- b = a**2 -->
<!-- end = time() -->
<!-- print("Time in seconds:", round(end-start,3)) -->
<!-- print(b[-10:]) -->
<!-- ``` -->
<div class="sourceCode" id="cb44"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">10_000_000</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>n1 <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>n2 <span class="op">=</span> n <span class="op">-</span> n1</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> ray.data.from_items([np.arange(n1), n1 <span class="op">+</span> np.arange(n2)])</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>ds.show()   <span class="co"># 2 rows</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> squares(row):</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {<span class="st">'squares'</span>: row[<span class="st">'item'</span>]<span class="op">**</span><span class="dv">2</span>}   <span class="co"># compute element-wise square of an array</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> ds.<span class="bu">map</span>(squares).take()</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now the runtime is 0.072 seconds.</p>
<!-- ```py -->
<!-- c.materialize()   # read all blocks into memory ... not clear -->
<!--                   # "materialize this dataset into object store memory" -->
<!-- ``` -->
</section>
<section id="vectorizable-dataset-transformations" class="level3">
<h3 class="anchored" data-anchor-id="vectorizable-dataset-transformations">Vectorizable dataset transformations</h3>
<p>The function <code>.map_batches()</code> will process batches (blocks) of rows, vectorizing operations on NumPy arrays inside each batch. We won’t study it here, as in practical terms it does not solve the specific problems in this course any faster. With <code>.map_batches()</code> you are limited in terms of data types that you can use inside a function passed to <code>.map_batches()</code> – in general it expects vectorizable NumPy arrays. If you are not planning to vectorize via <code>map_batches()</code>, use <code>map()</code> instead, and you will still get parallelization.</p>
<!-- ```py -->
<!-- ds = ray.data.from_items([1]) -->
<!-- ds.show() -->
<!-- def map_fn_with_large_output(batch): -->
<!--     for i in range(3): -->
<!--         yield {"large_output": np.ones((5,5))}   # use each row of this matrix to create an entry -->
<!--                                                  # len(np.ones((5,5))) = 5 \times yield 3 times => 15 entries {'large_output': array([1., 1., 1., 1., 1.])} -->
<!-- e = ds.map_batches(map_fn_with_large_output) -->
<!-- e.show() -->
<!-- ``` -->
<!-- In general, `map_batches()` will vectorize operations on NumPy arrays inside each batch. In other words, the -->
<!-- input function should be easily vectorizable via NumPy. E.g., going to our earlier example, the following -->
<!-- won't work: -->
<!-- ```py -->
<!-- ds = ray.data.range(1000) -->
<!-- import numpy as np -->
<!-- def squares(batch): -->
<!--     return {'squares': 1}   # return an integer as a value in each row => error -->
<!-- b = ds.map_batches(squares); b.show(5)   # error -->
<!-- def squares(batch): -->
<!--     return {'squares': np.array([1])}   # return a NumPy array => vectorizable -->
<!-- b = ds.map_batches(squares); b.show(5)   # works -->
<!-- def squares(batch): -->
<!--     x = 0 -->
<!--     for i in range(batch['id']): -->
<!--         x += i -->
<!--     return {'squares': np.array([x])}   # seemingly Ok, but will break when using it, as you are trying to use -->
<!--                                         # batch['id'] as an integer, and Ray will try to vectorize it over the batch -->
<!-- b = ds.map_batches(squares); b.show(5)   # TypeError -->
<!-- ``` -->
<!-- All this is to say that you are limited in terms of types that you can use inside a function that you pass to -->
<!-- `map_batches()` -- in general it expects vectorizable NumPy arrays. -->
</section>
<section id="slow-series-with-ray-data" class="level3">
<h3 class="anchored" data-anchor-id="slow-series-with-ray-data">Slow series with Ray Data</h3>
<p>Let’s start with a serial implementation:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>ray.init(configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>intervals <span class="op">=</span> ray.data.from_items([{<span class="st">"a"</span>: <span class="dv">1</span>, <span class="st">"b"</span>: <span class="dv">100_000_000</span>}])   <span class="co"># one item</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>intervals.show()</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> slow(row):</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(row[<span class="st">'a'</span>], row[<span class="st">'b'</span>]<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="st">"9"</span> <span class="kw">in</span> <span class="bu">str</span>(i):</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> <span class="fl">1.0</span> <span class="op">/</span> i</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>    row[<span class="st">'sum'</span>] <span class="op">=</span> total             <span class="co"># add key-value pair to the row</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> row</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>partial <span class="op">=</span> intervals.<span class="bu">map</span>(slow)      <span class="co"># define the calculation</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> partial.take()[<span class="dv">0</span>][<span class="st">'sum'</span>]   <span class="co"># request the result =&gt; start the calculation on 1 CPU core</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>I get the average runtime of 6.978 seconds. To parallelize this, you can redefine <code>intervals</code>:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>intervals <span class="op">=</span> ray.data.from_items([</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"a"</span>: <span class="dv">1</span>, <span class="st">"b"</span>: <span class="dv">50_000_000</span>},</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"a"</span>: <span class="dv">50_000_001</span>, <span class="st">"b"</span>: <span class="dv">100_000_000</span>},</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>partial <span class="op">=</span> intervals.<span class="bu">map</span>(slow)     <span class="co"># define the calculation</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="bu">sum</span>([p[<span class="st">'sum'</span>] <span class="cf">for</span> p <span class="kw">in</span> partial.take()])   <span class="co"># request the result =&gt; start the calculation on 2 CPU cores</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))   <span class="co"># 4.322, 4.857, 4.782 and 3.852 3.812 3.823</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>On 2 cores I get the average time of 3.765 seconds.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Question 14
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Parallelize this for 4 CPU cores. <strong>Hint</strong>: programmatically form a list of dictionaries, each containing two key-value pairs (<code>a</code> and <code>b</code>) with the sub-intervals.</p>
</div>
</div>
</div>
<!-- Solution: -->
<!-- ```py -->
<!-- n = 100_000_000 -->
<!-- ncores = 2 -->
<!-- ray.init(num_cpus=ncores, configure_logging=False) -->
<!-- size = n // ncores -->
<!-- edges = [(i*size+1, i*size+size) for i in range(ncores)] -->
<!-- if edges[-1][1] < n: edges[-1] = (edges[-1][0],n) -->
<!-- intervals = ray.data.from_items([{'a':w[0], 'b':w[1]} for w in edges]) -->
<!-- ``` -->
<p>On my laptop I am getting:</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td>ncores</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
</tr>
<tr class="even">
<td>wallclock runtime (sec)</td>
<td>6.978</td>
<td>3.765</td>
<td>1.675</td>
<td>1.574</td>
</tr>
</tbody>
</table>
<!-- The entire code is: -->
<!-- ```py -->
<!-- import ray -->
<!-- from time import time -->
<!-- def slow(row): -->
<!--     total = 0 -->
<!--     for i in range(row['a'], row['b']+1): -->
<!--         if not "9" in str(i): -->
<!--             total += 1.0 / i -->
<!--     row['sum'] = total -->
<!--     return row -->
<!-- n = 100_000_000 -->
<!-- ncores = 2 -->
<!-- ray.init(num_cpus=ncores, configure_logging=False) -->
<!-- size = n // ncores -->
<!-- edges = [(i*size+1, i*size+size) for i in range(ncores)] -->
<!-- if edges[-1][1] < n: edges[-1] = (edges[-1][0],n) -->
<!-- intervals = ray.data.from_items([{'a':w[0], 'b':w[1]} for w in edges]) -->
<!-- start = time() -->
<!-- partial = intervals.map(slow)     # define the calculation -->
<!-- total = sum([p['sum'] for p in partial.take()])   # request the result => start the calculation on 2 CPU cores -->
<!-- end = time() -->
<!-- print("Time in seconds:", round(end-start,3)) -->
<!-- print(total) -->
<!-- ``` -->
</section>
<section id="processing-ray-datasets-with-numba-compiled-functions" class="level3">
<h3 class="anchored" data-anchor-id="processing-ray-datasets-with-numba-compiled-functions">Processing Ray datasets with Numba-compiled functions</h3>
<p>So far we processed Ray datasets with non-Numba functions, either lambda (anonymous) or plain Python functions, and we obtained very good parallel scaling with multiple Ray processes. However, these functions are slower than their Numba-compiled versions.</p>
<p>Is it possible to <em>process Ray datasets with Numba-compiled functions</em>, similar to how earlier we executed Numba-compiled functions on remote workers? The answer is a <strong>firm yes</strong>, but I will leave it to you to write an implementation for the slow series problem. Even though I have the solution on my laptop, I am not providing it here, as I feel this would be an excellent take-home exercise.</p>
<p>A couple of considerations: 1. Numba does not work with Python dictionaries, instead providing its own dictionary type which is not compatible with Ray datasets. You can easily sidestep this problem, but you will have to find the solution yourself. 2. Very important: you must do small runs on workers to copy your functions over to them – no need to time these runs. Without this “pre-compilation” step you will not get fast execution on workers on the bigger problem the first time you run it.</p>
<!-- The solution is in `~/training/pythonHPC/slowSeriesNumbaRayData.py`. -->
<p>With this Numba-compiled processing, on my laptop I am getting:</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td>ncores</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
</tr>
<tr class="even">
<td>wallclock runtime (sec)</td>
<td>0.447</td>
<td>0.234</td>
<td>0.238</td>
<td>0.137</td>
</tr>
</tbody>
</table>
<p>I am not quite sure why going 2 → 4 cores does not result in better runtimes, but there could be some inherent overhead in Ray tasks implementation on my laptop that shows up in this small problem – or more likely the efficiency cores enter the calculation at this time?</p>
<p>With the same code on the training cluster I get better scaling:</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td>ncores</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
</tr>
<tr class="even">
<td>wallclock runtime (sec)</td>
<td>1.054</td>
<td>0.594</td>
<td>0.306</td>
<td>0.209</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="running-ray-workflows-on-a-single-node" class="level2">
<h2 class="anchored" data-anchor-id="running-ray-workflows-on-a-single-node">Running Ray workflows on a single node</h2>
<!-- Launching a single-node ray cluster -->
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-11-contents" aria-controls="callout-11" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Question 15
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-11" class="callout-11-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Let’s try running the slow series without Numba-compiled functions on the training cluster as a batch job.<br>
1. Save the entire Python code for the slow series problem into <code>rayPartialMap.py</code><br>
2. Modify the code to take <ncores> as a command-line argument:</ncores></p>
<div class="sourceCode" id="cb47"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>ncores <span class="op">=</span> <span class="bu">int</span>(sys.argv[<span class="dv">1</span>])</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span>ncores, configure_logging<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>and test it from the command line inside your interactive job</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> rayPartialMap.py <span class="va">$SLURM_CPUS_PER_TASK</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="3" type="1">
<li>Quit the interactive job.<br>
</li>
<li>Back on the login node, write a Slurm job submission script, in which you launch <code>rayPartialMap.py</code> in the last line of the script.<br>
</li>
<li>Submit your job with <code>sbatch</code> to 1, 2, 4, 8 CPU cores, all on the same node.</li>
</ol>
</div>
</div>
</div>
<!-- Solution: -->
<!-- ```sh -->
<!-- #!/bin/bash -->
<!-- #SBATCH --ntasks=4 --nodes=1 -->
<!-- #SBATCH --mem-per-cpu=1200 -->
<!-- #SBATCH --time=0:15:0 -->
<!-- # #SBATCH --account=... -->
<!-- cd ~/scratch/ray -->
<!-- module load python/3.12.4 arrow/19.0.1 -->
<!-- source hpc-env/bin/activate -->
<!-- python rayPartialMap.py $SLURM_CPUS_PER_TASK -->
<!-- ``` -->
<!-- ```sh -->
<!-- cass -->
<!-- cd ~/scratch/ray -->
<!-- sbatch submit.sh -->
<!-- ``` -->
<p>Testing on the training cluster:</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td>ncores</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
</tr>
<tr class="even">
<td>wallclock runtime (sec)</td>
<td>15.345</td>
<td>7.890</td>
<td>4.264</td>
<td>2.756</td>
</tr>
</tbody>
</table>
<p>Testing on Cedar (averaged over 2 runs):</p>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
</colgroup>
<tbody>
<tr class="odd">
<td>ncores</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>16</td>
<td>32</td>
</tr>
<tr class="even">
<td>wallclock runtime (sec)</td>
<td>18.263</td>
<td>9.595</td>
<td>5.228</td>
<td>3.048</td>
<td>2.069</td>
<td>1.836</td>
</tr>
</tbody>
</table>
<p>In our <a href="https://docs.alliancecan.ca/wiki/Ray">Ray documentation</a> there are instructions for launching a single-node Ray cluster. Strictly speaking, this is not necessary, as on a single machine (node) a call to <code>ray.init()</code> will start a new Ray cluster and will automatically connect to it.</p>
<!-- ```sh -->
<!-- export HEAD_NODE=$(hostname) -->
<!-- export RAY_PORT=34567 -->
<!-- ray start --head --node-ip-address=$HEAD_NODE --port=$RAY_PORT --num-cpus=$SLURM_CPUS_PER_TASK  --block & -->
<!-- sleep 10 -->
<!-- ``` -->
<!-- ```py -->
<!-- #import ray -->
<!-- #import os -->
<!-- #ray.init(address=f"{os.environ['HEAD_NODE']}:{os.environ['RAY_PORT']}",_node_ip_address=os.environ['HEAD_NODE']) -->
<!-- #print(ray.available_resources()) -->
<!-- ``` -->
</section>
<section id="running-ray-workflows-on-multiple-nodes" class="level2">
<h2 class="anchored" data-anchor-id="running-ray-workflows-on-multiple-nodes">Running Ray workflows on multiple nodes</h2>
<!-- Launching a multi-node ray cluster -->
<p>To run Ray workflows on multiple cluster nodes, you <em>must</em> create a virtual Ray cluster first. You can find details of Ray’s virtual clusters in the official Ray documentation https://docs.ray.io/en/latest/cluster/getting-started.html.</p>
<p>Here we’ll take a look at the example which I copied and adapted from our documentation at https://docs.alliancecan.ca/wiki/Ray#Multiple_Nodes. I made several changes in this workflow:</p>
<ol type="1">
<li>made it interactive,</li>
<li>not creating virtual environments in <code>$SLURM_TMPDIR</code> inside the job, but using the already existing one in <code>/project/def-sponsor00/shared/hpc-env</code>,</li>
<li>removed GPUs.</li>
</ol>
<p>Let’s quit our current Slurm job (if any), back on the login node start the following interactive job, and then run the following commands:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load python/3.12.4 arrow/19.0.1 scipy-stack/2025a netcdf/4.9.2</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="bu">source</span> /project/def-sponsor00/shared/hpc-env/bin/activate</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="ex">salloc</span> <span class="at">--nodes</span> 2 <span class="at">--ntasks-per-node</span><span class="op">=</span>1 <span class="at">--cpus-per-task</span><span class="op">=</span>2 <span class="at">--mem-per-cpu</span><span class="op">=</span>3600 <span class="at">--time</span><span class="op">=</span>0:60:0</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">HEAD_NODE</span><span class="op">=</span><span class="va">$(</span><span class="fu">hostname</span><span class="va">)</span>   <span class="co"># head node's address -- different from the login node!</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">RAY_PORT</span><span class="op">=</span>34567          <span class="co"># a port to start Ray on the head node </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next, we will start a Ray cluster on the head node as a background process:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ex">ray</span> start <span class="at">--head</span> <span class="at">--node-ip-address</span><span class="op">=</span><span class="va">$HEAD_NODE</span> <span class="at">--port</span><span class="op">=</span><span class="va">$RAY_PORT</span> <span class="at">--num-cpus</span><span class="op">=</span><span class="va">$SLURM_CPUS_PER_TASK</span> <span class="at">--block</span> <span class="kw">&amp;</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sleep</span> 10   <span class="co"># wait for the prompt; it'll ask to enable usage stats collection</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Eventually should say "Ray runtime started."</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Then on each node inside our Slurm job, except the head node, we launch the worker nodes of the Ray cluster:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> <span class="op">&lt;&lt; EOF</span> <span class="op">&gt;</span> launchRay.sh</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="st">#!/bin/bash</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="st">module load python/3.12.4 arrow/19.0.1 scipy-stack/2025a netcdf/4.9.2</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="st">source /project/def-sponsor00/shared/hpc-env/bin/activate</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="st">if [[ "</span><span class="dt">\$</span><span class="st">SLURM_PROCID" -eq "0" ]]; then   # if MPI rank is 0</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span class="st">        echo "Ray head node already started..."</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="st">        sleep 10</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="st">else</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="st">        ray start --address "</span><span class="va">${HEAD_NODE}</span><span class="st">:</span><span class="va">${RAY_PORT}</span><span class="st">" --num-cpus="</span><span class="va">${SLURM_CPUS_PER_TASK}</span><span class="st">" --block</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a><span class="st">        sleep 5</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="st">        echo "Ray worker started!"</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a><span class="st">fi</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a><span class="op">EOF</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a><span class="fu">chmod</span> u+x launchRay.sh</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a><span class="ex">srun</span> launchRay.sh <span class="kw">&amp;</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a><span class="va">ray_cluster_pid</span><span class="op">=</span><span class="va">$!</span>   <span class="co"># get its process ID</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next, we launch a Python script that connects to the Ray cluster, checks the nodes and all available CPUs:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>ray.init(address<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>os<span class="sc">.</span>environ[<span class="st">'HEAD_NODE'</span>]<span class="sc">}</span><span class="ss">:</span><span class="sc">{</span>os<span class="sc">.</span>environ[<span class="st">'RAY_PORT'</span>]<span class="sc">}</span><span class="ss">"</span>,_node_ip_address<span class="op">=</span>os.environ[<span class="st">'HEAD_NODE'</span>])</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Eventually should say "Connected to Ray cluster."</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Nodes in the Ray cluster:"</span>, ray.nodes())   <span class="co"># should see two nodes with 'Alive' status</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.available_resources())                  <span class="co"># should see 4 CPUs and 2 nodes</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, from bash, we shut down the Ray worker nodes:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="bu">kill</span> <span class="va">$ray_cluster_pid</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>and terminate the job.</p>
</section>
<section id="distributed-data-processing-on-ray-and-io-bound-workflows" class="level2">
<h2 class="anchored" data-anchor-id="distributed-data-processing-on-ray-and-io-bound-workflows">Distributed data processing on Ray and I/O-bound workflows</h2>
<section id="simple-distributed-dataset-example" class="level3">
<h3 class="anchored" data-anchor-id="simple-distributed-dataset-example">Simple distributed dataset example</h3>
<p>With multiple CPU cores available, run the following Python code line by line, while watching memory usage in a separate window with <code>htop --filter "ray::IDLE"</code>:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>ray.init(configure_logging<span class="op">=</span><span class="va">False</span>, _system_config<span class="op">=</span>{ <span class="st">'automatic_object_spilling_enabled'</span>:<span class="va">False</span> })</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. hide Ray's copious logging output</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. start as many ray::IDLE process as the physical number of cores -- we'll use only two of them below</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. disable automatic object spilling to disk</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> ray.data.from_items([(<span class="dv">800</span>,<span class="dv">800</span>,<span class="dv">800</span>), (<span class="dv">800</span>,<span class="dv">800</span>,<span class="dv">800</span>)])   <span class="co"># 800**3 will take noticeable 3.81GB memory</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>b.show()</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> initArray(row):</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>    nx, ny, nz <span class="op">=</span> row[<span class="st">'item'</span>]</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>    row[<span class="st">'array'</span>] <span class="op">=</span> np.zeros((nx,ny,nz))</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> row</span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> b.<span class="bu">map</span>(initArray)</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>c.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’ll see the two arrays being initialized in memory, on two processes, with a couple of GBs of memory consumed per process. Ray writes (“spills”) objects to storage once they are no longer in use, as it tries to minimize the total number of “materialized” (in-memory) blocks. On Linux and MacOS, the temporary spill folder is <code>/tmp/ray</code>, but you can customize its location as described <a href="https://docs.ray.io/en/latest/ray-core/objects/object-spilling.html">here</a>.</p>
<p>With the automatic object spilling to disk disabled (our second flag to <code>ray.init()</code> above), these arrays will stay in memory.</p>
<p>With that flag removed, and hence with the usual automatic object spilling to disk, these array blocks will be automatically written to disk, and the memory usage goes back to zero after a fraction of a second. If next you try to access these arrays, e.g.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> c.take()</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(d[<span class="dv">0</span>][<span class="st">'array'</span>])   <span class="co"># numpy.ndarray</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>d[<span class="dv">0</span>][<span class="st">'array'</span>].shape   <span class="co"># (800, 800, 800)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>they will be loaded temporarily into memory, which you can monitor with <code>htop --filter "ray::IDLE"</code>.</p>
<!-- Ray uses "streaming execution" 

<!-- - Ray data execution via lazy streaming https://docs.ray.io/en/latest/data/data-internals.html#streaming-execution -->
<!-- - How to distribute data by hand? -->
<!-- - Reading and writing data in parallel. -->
<!-- - From 6 hours to 1.5 minutes using Ray, DynamoDB and Python -->
<!--   https://medium.com/@hagai.arad/from-6-hours-to-1-5-minutes-using-ray-dynamodb-and-python-efaa1e76f771 -->
</section>
<section id="pandas-on-ray-modin" class="level3">
<h3 class="anchored" data-anchor-id="pandas-on-ray-modin">Pandas on Ray (Modin)</h3>
<p>You can run many types of I/O workflows on top of Ray. One famous example is “Modin” (previously called Pandas on Ray) which is a drop-in replacement for Pandas on top of Ray. We won’t study here, but it will run all your pandas workflows, and you don’t need to modify your code, except importing the library, e.g.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.read_csv(<span class="st">"filename.csv"</span>, <span class="op">&lt;</span>other flags<span class="op">&gt;</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>will become</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> modin.pandas <span class="im">as</span> pd</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.read_csv(<span class="st">"filename.csv"</span>, <span class="op">&lt;</span>other flags<span class="op">&gt;</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Modin will run your workflows using Ray tasks on multiple cores, potentially speeding up large workflows. You can find more information at https://github.com/modin-project/modin</p>
<p>Similarly, many other Ray Data read functions will read your data in parallel, distributing it to multiple processes if necessary for larger processing:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>&gt;&gt;&gt; import ray</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>&gt;&gt;&gt; ray.data.read_</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>ray.data.read_api                 ray.data.read_databricks_tables(  ray.data.read_mongo(              ray.data.read_sql(</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>ray.data.read_bigquery(           ray.data.read_datasource(         ray.data.read_numpy(              ray.data.read_text(</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>ray.data.read_binary_files(       ray.data.read_images(             ray.data.read_parquet(            ray.data.read_tfrecords(</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>ray.data.read_csv(                ray.data.read_json(               ray.data.read_parquet_bulk(       ray.data.read_webdataset(</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<!-- - Mars (a tensor-based framework to scale NumPy, Pandas, and scikit-learn applications) can run on top of Ray, -->
<!-- - Dask tasks can run on top of Ray, -->
</section>
<section id="processing-images" class="level3">
<h3 class="anchored" data-anchor-id="processing-images">Processing images</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>This example won’t work on the training cluster, where <code>arrow/14.0.1</code> was compiled without proper filesystem support. However, I can demo this on my computer.</p>
</div>
</div>
<p>Here is a simple example of processing a directory with images with Ray Data. Suppose we have a <span class="math inline">\(2874\times
2154\)</span> image <code>tuscany.avif</code>. Let’s crop 100 random <span class="math inline">\(300\times 300\)</span> images out of it:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="va">tmpdir</span><span class="op">=</span><span class="va">${RANDOM}${RANDOM}</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> <span class="at">-p</span> ~/<span class="va">$tmpdir</span> <span class="kw">&amp;&amp;</span> <span class="bu">cd</span> ~/<span class="va">$tmpdir</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="ex">pyenv</span> activate hpc-env</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="fu">wget</span> https://wgpages.netlify.app/img/tuscany.jpg</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="fu">ls</span> <span class="at">-l</span> tuscany.jpg</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> <span class="at">-p</span> images</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a><span class="va">width</span><span class="op">=</span><span class="va">$(</span><span class="ex">identify</span> tuscany.jpg <span class="kw">|</span> <span class="fu">awk</span> <span class="st">'{print $3}'</span> <span class="kw">|</span> <span class="fu">awk</span> <span class="at">-Fx</span> <span class="st">'{print $1}'</span><span class="va">)</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="va">height</span><span class="op">=</span><span class="va">$(</span><span class="ex">identify</span> tuscany.jpg <span class="kw">|</span> <span class="fu">awk</span> <span class="st">'{print $3}'</span> <span class="kw">|</span> <span class="fu">awk</span> <span class="at">-Fx</span> <span class="st">'{print $2}'</span><span class="va">)</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> num <span class="kw">in</span> <span class="va">$(</span><span class="fu">seq</span> <span class="at">-w</span> 00 99<span class="va">)</span><span class="kw">;</span> <span class="cf">do</span>   <span class="co"># crop it into hundred 300x300 random images</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="va">$num</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>    <span class="va">x</span><span class="op">=</span><span class="va">$(</span><span class="bu">echo</span> <span class="st">"scale=8; </span><span class="va">$RANDOM</span><span class="st"> / 32767 * (</span><span class="va">$width</span><span class="st">-300)"</span> <span class="kw">|</span> <span class="fu">bc</span><span class="va">)</span>   <span class="co"># $RANDOM goes from 0 to 32767</span></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>    <span class="va">x</span><span class="op">=</span><span class="va">$(</span><span class="bu">echo</span> <span class="va">$x</span> <span class="kw">|</span> <span class="fu">awk</span> <span class="st">'{print int($1+0.5)}'</span><span class="va">)</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>    <span class="va">y</span><span class="op">=</span><span class="va">$(</span><span class="bu">echo</span> <span class="st">"scale=8; </span><span class="va">$RANDOM</span><span class="st"> / 32767 * (</span><span class="va">$height</span><span class="st">-300)"</span> <span class="kw">|</span> <span class="fu">bc</span><span class="va">)</span></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>    <span class="va">y</span><span class="op">=</span><span class="va">$(</span><span class="bu">echo</span> <span class="va">$y</span> <span class="kw">|</span> <span class="fu">awk</span> <span class="st">'{print int($1+0.5)}'</span><span class="va">)</span></span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>    <span class="ex">convert</span> tuscany.jpg <span class="at">-crop</span> 300x300+<span class="va">$x</span>+<span class="va">$y</span> images/small<span class="va">$num</span>.png</span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a><span class="cf">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now we will load these images into Ray Data. First, let’s set <code>export RAY_DEDUP_LOGS=0</code>, and then do:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> ray.data.read_images(<span class="st">"images/"</span>)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>ds   <span class="co"># 100 rows (one image per row) split into ... blocks</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>ds.take(<span class="dv">1</span>)[<span class="dv">0</span>]                  <span class="co"># first image</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(ds.take(<span class="dv">1</span>)[<span class="dv">0</span>][<span class="st">"image"</span>])   <span class="co"># stored as a numpy array</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>ds.take(<span class="dv">1</span>)[<span class="dv">0</span>][<span class="st">"image"</span>].shape   <span class="co"># 300x300 and three channels (RGB)</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>ds.take(<span class="dv">1</span>)[<span class="dv">0</span>][<span class="st">"image"</span>].<span class="bu">max</span>()   <span class="co"># 255 =&gt; they are stored as 8-bit images (0..255)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s print min/max values for all images:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minmax(row):</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(row[<span class="st">"image"</span>].<span class="bu">min</span>(), row[<span class="st">"image"</span>].<span class="bu">max</span>())</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> row  <span class="co"># must return a dictionary, otherwise `map` will fail</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> ds.<span class="bu">map</span>(minmax)   <span class="co"># on output; we scheduled the calculation, but have not started it yet</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>b.materialize()      <span class="co"># force the calculation =&gt; now we see printouts from individual rows</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s compute their negatives:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> negate(row):</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {<span class="st">'image'</span>: <span class="dv">255</span><span class="op">-</span>row[<span class="st">'image'</span>]}</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>negative <span class="op">=</span> ds.<span class="bu">map</span>(negate)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>negative.write_images(<span class="st">"output"</span>, column<span class="op">=</span><span class="st">'image'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In <code>output/</code> subdirectory you will find 100 negative images.</p>
</section>
<section id="coding-parallel-io-by-hand" class="level3">
<h3 class="anchored" data-anchor-id="coding-parallel-io-by-hand">Coding parallel I/O by hand</h3>
<p>In Ray Data you can also write your own parallel I/O workflows by hand, defining functions to process rows that will load certain data/file into a specific row, e.g.&nbsp;with something like this:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> ray.data.from_items([</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    {<span class="st">'file'</span>: <span class="st">'/path/to/file1'</span>},</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    {<span class="st">'file'</span>: <span class="st">'/path/to/file2'</span>},</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    {<span class="st">'file'</span>: <span class="st">'/path/to/file3'</span>}</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> readFileInParallel(row):</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;</span>load data <span class="im">from</span> <span class="bu">file</span> row[<span class="st">'file'</span>]<span class="op">&gt;</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;</span>process these data<span class="op">&gt;</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>    row[<span class="st">'status'</span>] <span class="op">=</span> <span class="st">'done'</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> row</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> a.<span class="bu">map</span>(readFileInParallel)</span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>b.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="a-cpu-intensive-problem-without-reduction" class="level3">
<h3 class="anchored" data-anchor-id="a-cpu-intensive-problem-without-reduction">A CPU-intensive problem without reduction</h3>
<p>So far we’ve been working with problems where calculations from individual tasks add to form a single number (sum of a slow series) – this is called <em>reduction</em>. Let’s now look at a problem without reduction, i.e.&nbsp;where results stay distributed.</p>
<p>Let’s compute a mathematical <a href="https://en.wikipedia.org/wiki/Julia_set">Julia set</a> defined as a set of points on the complex plane that remain bound under an infinite recursive transformation <span class="math inline">\(z_{i+1}=f(z_i)\)</span>. For the recursive function, we will use the traditional form <span class="math inline">\(f(z)=z^2+c\)</span>, where <span class="math inline">\(c\)</span> is a complex constant. Here is our algorithm:</p>
<ol type="1">
<li>pick a point <span class="math inline">\(z_0\in\mathbb{C}\)</span></li>
<li>compute iterations <span class="math inline">\(z_{i+1}=z_i^2+c\)</span> until <span class="math inline">\(|z_i|&gt;4\)</span> (arbitrary fixed radius; here <span class="math inline">\(c\)</span> is a complex constant)</li>
<li>store the iteration number <span class="math inline">\(\xi(z_0)\)</span> at which <span class="math inline">\(z_i\)</span> reaches the circle <span class="math inline">\(|z|=4\)</span></li>
<li>limit max iterations at 255<br>
4.1 if <span class="math inline">\(\xi(z_0)\lt 255\)</span>, then <span class="math inline">\(z_0\)</span> is a stable point<br>
4.2 the quicker a point diverges, the lower its <span class="math inline">\(\xi(z_0)\)</span> is</li>
<li>plot <span class="math inline">\(\xi(z_0)\)</span> for all <span class="math inline">\(z_0\)</span> in a rectangular region &nbsp; <span class="math inline">\(-1.2&lt;=\mathfrak{Re}(z_0)&lt;=1.2\)</span> &nbsp; and &nbsp; <span class="math inline">\(-1.2&lt;=\mathfrak{Im}(z_0)&lt;=1.2\)</span></li>
</ol>
<p>We should get something conceptually similar to this figure (here <span class="math inline">\(c = 0.355 + 0.355i\)</span>; we’ll get drastically different fractals for different values of <span class="math inline">\(c\)</span>):</p>
<p><img src="2000a.png" class="img-fluid"></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>You might want to try these values too:<br>
<span class="math inline">\(c = 1.2e^{1.1πi}\)</span> <span class="math inline">\(~\Rightarrow~\)</span> original textbook example<br>
<span class="math inline">\(c = -0.4-0.59i\)</span> and 1.5X zoom-out <span class="math inline">\(~\Rightarrow~\)</span> denser spirals<br>
<span class="math inline">\(c = 1.34-0.45i\)</span> and 1.8X zoom-out <span class="math inline">\(~\Rightarrow~\)</span> beans<br>
<span class="math inline">\(c = 0.34-0.05i\)</span> and 1.2X zoom-out <span class="math inline">\(~\Rightarrow~\)</span> connected spiral boots</p>
</div>
</div>
<p>As you must be accustomed by now, this calculation runs much faster when implemented in a compiled language. I tried Julia (0.676s) and Chapel (0.489s), in both cases running the code on my laptop in serial (one CPU core), both with exactly the same workflow and the same <span class="math inline">\(2000^2\)</span> image size.</p>
<p>Below is the serial implementation in Python – let’s save it as <code>juliaSetSerial.py</code>:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>nx <span class="op">=</span> ny <span class="op">=</span> <span class="dv">2000</span>   <span class="co"># image size</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pixel(z):</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> <span class="fl">0.355</span> <span class="op">+</span> <span class="ot">0.355j</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">256</span>):</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> z<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> c</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(z) <span class="op">&gt;=</span> <span class="dv">4</span>:</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> i</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">255</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Computing Julia set ..."</span>)</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>stability <span class="op">=</span> np.zeros((nx,ny), dtype<span class="op">=</span>np.int32)</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nx):</span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(ny):</span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>        point <span class="op">=</span> <span class="fl">1.2</span><span class="op">*</span>((<span class="dv">2</span><span class="op">*</span>(i<span class="op">+</span><span class="fl">0.5</span>)<span class="op">/</span>nx<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> (<span class="dv">2</span><span class="op">*</span>(k<span class="op">+</span><span class="fl">0.5</span>)<span class="op">/</span>ny<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="ot">1j</span>) <span class="co"># rescale to -1.2:1.2 in the complex plane</span></span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>        stability[i,k] <span class="op">=</span> pixel(point)</span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-26"><a href="#cb64-26" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> netCDF4 <span class="im">as</span> nc</span>
<span id="cb64-27"><a href="#cb64-27" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> nc.Dataset(<span class="st">'test.nc'</span>, <span class="st">'w'</span>, <span class="bu">format</span><span class="op">=</span><span class="st">'NETCDF4'</span>)</span>
<span id="cb64-28"><a href="#cb64-28" aria-hidden="true" tabindex="-1"></a>f.createDimension(<span class="st">'x'</span>, nx)</span>
<span id="cb64-29"><a href="#cb64-29" aria-hidden="true" tabindex="-1"></a>f.createDimension(<span class="st">'y'</span>, ny)</span>
<span id="cb64-30"><a href="#cb64-30" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> f.createVariable(<span class="st">'stability'</span>, <span class="st">'i4'</span>, (<span class="st">'x'</span>, <span class="st">'y'</span>))   <span class="co"># 4-byte integer</span></span>
<span id="cb64-31"><a href="#cb64-31" aria-hidden="true" tabindex="-1"></a>output[:,:] <span class="op">=</span> stability</span>
<span id="cb64-32"><a href="#cb64-32" aria-hidden="true" tabindex="-1"></a>f.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here we are timing purely the computational part, not saving the image to a NetCDF file. Let’s run it and look at the result in ParaView! When running this on my laptop, it takes 9.220 seconds.</p>
<p>How would you parallelize this problem with <code>ray.data</code>? The main points to remember are:</p>
<ol type="1">
<li>You need to subdivide your problem into blocks – let’s do this in the <code>ny</code> (vertical) dimension.</li>
<li>You have to construct a dataset with each row containing inputs for a single task. These inputs will be the size of each image block and the offset (the starting row number of this block inside the image).</li>
<li>You need to write a function <code>computeStability(row)</code> that acts on each input row in the dataset. The result will be a NumPy array stored as a new entry <code>stability</code> in each row.</li>
<li>To write the final image to a NetCDF file, you need to merge these arrays into a single <span class="math inline">\(2000\times 2000\)</span> array, and then write this square array to disk.</li>
</ol>
<p>The solution is in the file <code>juliaSetParallel.py</code> on instructor’s laptop. Here are the runtimes for <span class="math inline">\(2000\times 2000\)</span> (averaged over three runs):</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td>ncores</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
</tr>
<tr class="even">
<td>wallclock runtime (sec)</td>
<td>9.220</td>
<td>4.869</td>
<td>2.846</td>
<td>2.210</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="quickly-on-parallel-python-in-ml-frameworks-marie" class="level2">
<h2 class="anchored" data-anchor-id="quickly-on-parallel-python-in-ml-frameworks-marie">Quickly on parallel Python in ML frameworks (Marie)</h2>
<!-- Marie will say a word about parallel Python in ML frameworks. The exact methods are different for each -->
<!-- framework, so we are not teaching them, just providing a quick overview of what different frameworks provide -->
<!-- in terms of parallel computing. -->
<p>Machine learning (ML) frameworks in Python usually come with their own parallelization tools, so you do not need to use general parallel libraries that we discussed in this course.</p>
<section id="jax" class="level3">
<h3 class="anchored" data-anchor-id="jax">JAX</h3>
<ul>
<li><a href="https://jax.readthedocs.io/en/latest/sharded-computation.html" target="_blank">Single-Program Multi-Data</a></li>
<li><a href="https://jax.readthedocs.io/en/latest/advanced_guide.html" target="_blank">Several parallel computing sections in the advanced guide</a></li>
</ul>
</section>
<section id="pytorch" class="level3">
<h3 class="anchored" data-anchor-id="pytorch">PyTorch</h3>
<ul>
<li><a href="https://pytorch.org/tutorials/beginner/dist_overview.html" target="_blank">PyTorch Distributed (torch.distributed) Overview</a></li>
<li><a href="https://pytorch.org/tutorials/distributed/home.html" target="_blank">Distributed and Parallel Training Tutorials</a></li>
<li><a href="https://pytorch.org/tutorials/intermediate/ddp_tutorial.html" target="_blank">Getting Started with DistributedDataParallel (DDP) module</a></li>
<li><a href="https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html" target="_blank">Using multiple GPUs with DataParallel</a></li>
</ul>
</section>
<section id="tensorflow" class="level3">
<h3 class="anchored" data-anchor-id="tensorflow">TensorFlow</h3>
<ul>
<li><a href="https://www.tensorflow.org/guide/distributed_training" target="_blank">Distributed training with TensorFlow</a></li>
<li><a href="https://www.tensorflow.org/guide/keras/distributed_training" target="_blank">Multi-GPU and distributed training</a></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/folio\.vastcloud\.org");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>