<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Running parallel Ray workflows – Various courses</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-707d8167ce6003fca903bfe2be84ab7f.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-960d9d362f81d399278ec3e29b622b37.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-e7f4145358ce1d0cd37d8d374dbb44f9.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="site_libs/bootstrap/bootstrap-960d9d362f81d399278ec3e29b622b37.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#across-multiple-cluster-nodes" id="toc-across-multiple-cluster-nodes" class="nav-link active" data-scroll-target="#across-multiple-cluster-nodes">… across multiple cluster nodes</a></li>
  <li><a href="#abstract" id="toc-abstract" class="nav-link" data-scroll-target="#abstract">Abstract</a></li>
  <li><a href="#installation" id="toc-installation" class="nav-link" data-scroll-target="#installation">Installation</a></li>
  <li><a href="#initializing-ray" id="toc-initializing-ray" class="nav-link" data-scroll-target="#initializing-ray">Initializing Ray</a></li>
  <li><a href="#ray-tasks" id="toc-ray-tasks" class="nav-link" data-scroll-target="#ray-tasks">Ray tasks</a></li>
  <li><a href="#loosely-coupled-parallel-problem" id="toc-loosely-coupled-parallel-problem" class="nav-link" data-scroll-target="#loosely-coupled-parallel-problem">Loosely coupled parallel problem</a>
  <ul class="collapse">
  <li><a href="#speeding-up-the-slow-series-with-numba" id="toc-speeding-up-the-slow-series-with-numba" class="nav-link" data-scroll-target="#speeding-up-the-slow-series-with-numba">Speeding up the slow series with Numba</a></li>
  <li><a href="#running-numba-compiled-functions-as-ray-tasks" id="toc-running-numba-compiled-functions-as-ray-tasks" class="nav-link" data-scroll-target="#running-numba-compiled-functions-as-ray-tasks">Running Numba-compiled functions as Ray tasks</a></li>
  <li><a href="#running-on-one-cluster-node" id="toc-running-on-one-cluster-node" class="nav-link" data-scroll-target="#running-on-one-cluster-node">Running on one cluster node</a></li>
  <li><a href="#running-on-multiple-cluster-nodes" id="toc-running-on-multiple-cluster-nodes" class="nav-link" data-scroll-target="#running-on-multiple-cluster-nodes">Running on multiple cluster nodes</a></li>
  <li><a href="#alternative-parallel-implementation-via-ray-data" id="toc-alternative-parallel-implementation-via-ray-data" class="nav-link" data-scroll-target="#alternative-parallel-implementation-via-ray-data">Alternative parallel implementation via Ray Data</a></li>
  </ul></li>
  <li><a href="#tightly-coupled-parallel-problem" id="toc-tightly-coupled-parallel-problem" class="nav-link" data-scroll-target="#tightly-coupled-parallel-problem">Tightly coupled parallel problem</a>
  <ul class="collapse">
  <li><a href="#serial-code" id="toc-serial-code" class="nav-link" data-scroll-target="#serial-code">Serial code</a></li>
  <li><a href="#persistent-storage-on-ray-workers" id="toc-persistent-storage-on-ray-workers" class="nav-link" data-scroll-target="#persistent-storage-on-ray-workers">Persistent storage on Ray workers</a></li>
  <li><a href="#back-to-the-poisson-solver" id="toc-back-to-the-poisson-solver" class="nav-link" data-scroll-target="#back-to-the-poisson-solver">Back to the Poisson solver</a></li>
  <li><a href="#scalable-version" id="toc-scalable-version" class="nav-link" data-scroll-target="#scalable-version">Scalable version</a></li>
  <li><a href="#important-performance-tip" id="toc-important-performance-tip" class="nav-link" data-scroll-target="#important-performance-tip">Important performance tip</a></li>
  <li><a href="#running-on-one-cluster-node-1" id="toc-running-on-one-cluster-node-1" class="nav-link" data-scroll-target="#running-on-one-cluster-node-1">Running on one cluster node</a></li>
  <li><a href="#running-on-multiple-cluster-nodes-1" id="toc-running-on-multiple-cluster-nodes-1" class="nav-link" data-scroll-target="#running-on-multiple-cluster-nodes-1">Running on multiple cluster nodes</a></li>
  </ul></li>
  <li><a href="#other-ray-workloads" id="toc-other-ray-workloads" class="nav-link" data-scroll-target="#other-ray-workloads">Other Ray workloads</a></li>
  <li><a href="#links" id="toc-links" class="nav-link" data-scroll-target="#links">Links</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Running parallel Ray workflows</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="across-multiple-cluster-nodes" class="level2">
<h2 class="anchored" data-anchor-id="across-multiple-cluster-nodes">… across multiple cluster nodes</h2>
</section>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p><a href="https://docs.ray.io/en/latest" target="_blank">Ray</a> is a unified framework for scaling AI and general Python workflows. Outside of machine learning (ML), its core distributed runtime and data libraries can be used for writing parallel applications that launch multiple processes, both on the same node and across multiple cluster nodes. These processes can subsequently execute a variety of workloads, e.g.&nbsp;Numba-compiled functions, NumPy array calculations, and even GPU-enabled codes.</p>
<p>In this webinar, we will focus on scaling Ray workflows to multiple HPC cluster nodes to speed up various (non-ML) numerical workflows. We will look at both a loosely coupled (embarrassingly parallel) problem with a slowly converging series (the harmonic series with some terms taken out) and a tightly coupled parallel problem.</p>
</section>
<section id="installation" class="level2">
<h2 class="anchored" data-anchor-id="installation">Installation</h2>
<p>On my computer, with <code>pyenv</code> installed earlier:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pyenv</span> install 3.12.7</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">unlink</span> ~/.pyenv/versions/hpc-env</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">pyenv</span> virtualenv 3.12.7 hpc-env   <span class="co"># goes into ~/.pyenv/versions/&lt;version&gt;/envs/hpc-env</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ex">pyenv</span> activate hpc-env</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install numpy numba</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install <span class="at">--upgrade</span> <span class="st">"ray[default]"</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install <span class="at">--upgrade</span> <span class="st">"ray[data]"</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="ex">pyenv</span> deactivate</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>On a production HPC cluster:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load python/3.12.4 arrow/18.1.0 scipy-stack/2024b netcdf/4.9.2</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">virtualenv</span> <span class="at">--no-download</span> pythonhpc-env</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">source</span> pythonhpc-env/bin/activate</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install <span class="at">--no-index</span> <span class="at">--upgrade</span> pip</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install <span class="at">--no-index</span> numba</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="ex">avail_wheels</span> <span class="st">"ray"</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install <span class="at">--no-index</span> ray</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="ex">deactivate</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<!-- ```sh -->
<!-- cass -->
<!-- mkdir -p /project/def-sponsor00/shared && cd /project/def-sponsor00/shared -->
<!-- module load python/3.12.4 arrow/18.1.0 scipy-stack/2024b netcdf/4.9.2 -->
<!-- virtualenv --no-download pythonhpc-env -->
<!-- source pythonhpc-env/bin/activate -->
<!-- pip install --no-index --upgrade pip -->
<!-- pip install --no-index numba -->
<!-- avail_wheels "ray" -->
<!-- pip install --no-index ray -->
<!-- ... -->
<!-- deactivate -->
<!-- chmod og+X,og-r /project/def-sponsor00/shared -->
<!-- chmod -R og+rX /project/def-sponsor00/shared/pythonhpc-env -->
<!-- ``` -->
<p>To use it:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load StdEnv/2023 python/3.12.4 arrow/17.0.0 scipy-stack/2024a netcdf/4.9.2</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">source</span> /project/def-sponsor00/shared/pythonhpc-env/bin/activate</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="initializing-ray" class="level2">
<h2 class="anchored" data-anchor-id="initializing-ray">Initializing Ray</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>ray.init()   <span class="co"># start a Ray cluster  and connect to it</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>             <span class="co"># no longer necessary, will run by default when you first use it</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>However, <code>ray.init()</code> is very useful for passing options at initialization. For example, Ray is quite verbose when you do things in it. To turn off this logging output to the terminal, you can do</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>ray.init(configure_logging<span class="op">=</span><span class="va">False</span>)   <span class="co"># hide Ray's copious logging output</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You can run <code>ray.init()</code> only once. If you want to re-run it, first you need to run <code>ray.shutdown()</code>. Alternatively, you can pass the argument <code>ignore_reinit_error=True</code> to the call.</p>
<p>You can specify the number of cores for Ray to use, and you can combine multiple options, e.g.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">4</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>If not specified, Ray will use all available CPU cores, e.g.&nbsp;on my laptop <code>ray.init()</code> will start 8 ray::IDLE processes (workers), and you can monitor these in a separate shell with <code>htop --filter "ray::IDLE"</code> command (you may want to hide threads – typically thrown in green – with Shift+H).</p>
</section>
<section id="ray-tasks" class="level2">
<h2 class="anchored" data-anchor-id="ray-tasks">Ray tasks</h2>
<p>In Ray you can execute any Python function asynchronously on separate workers. Such functions are called <strong>Ray remote functions</strong>, and their asynchronous invocations are called <strong>Ray tasks</strong>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>ray.init(configure_logging<span class="op">=</span><span class="va">False</span>)   <span class="co"># optional</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span>             <span class="co"># declare that we want to run this function remotely</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> square(x):</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> x</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> square.remote(<span class="dv">10</span>)   <span class="co"># launch/schedule a remote calculation (non-blocking call)</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(r)                 <span class="co"># ray._raylet.ObjectRef (object reference)</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>ray.get(r)              <span class="co"># retrieve the result (=100) (blocking call)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The calculation may happen any time between <code>&lt;function&gt;.remote()</code> and <code>ray.get()</code> calls, i.e.&nbsp;it does not necessarily start when you launch it. This is called <strong>lazy execution</strong>: the operation is often executed when you try to access the result.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> square.remote(<span class="dv">10</span>)   <span class="co"># launch a remote calculation</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>ray.cancel(a)           <span class="co"># cancel it</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>ray.get(a)              <span class="co"># either error or 100, depending on whether the calculation</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># has finished before cancellation</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You can launch several Ray tasks at once, to be executed in parallel in the background, and you can retrieve their results either individually or through the list:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> [square.remote(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>)]   <span class="co"># launch four parallel tasks (non-blocking call)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>([ray.get(r[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>)])   <span class="co"># retrieve the results (multiple blocking calls)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(r))          <span class="co"># more compact way to do the same (single blocking call)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="loosely-coupled-parallel-problem" class="level2">
<h2 class="anchored" data-anchor-id="loosely-coupled-parallel-problem">Loosely coupled parallel problem</h2>
<p>When I teach parallel computing in other languages (Julia, Chapel), the approach is to take a numerical problem and parallelize it using multiple processors, and concentrate on various issues and bottlenecks (variable locks, load balancing, false sharing, messaging overheads, etc.) that lead to less than 100% <strong>parallel efficiency</strong>. For the numerical problem I usually select something that is very simple to code, yet forces the computer to do brute-force calculation that cannot be easily optimized.</p>
<p>One such problem is a <em>slow series</em>. It is a well-known fact that the harmonic series <span class="math inline">\(\sum\limits_{k=1}^\infty{1\over k}\)</span> diverges. It turns out that if we omit the terms whose denominators in decimal notation contain any <em>digit</em> or <em>string of digits</em>, it converges, albeit very slowly (Schmelzer &amp; Baillie 2008), e.g.</p>
<p><img src="./fig/slow.png" class="img-fluid"></p>
<p>But this slow convergence is actually good for us: our answer will be bounded by the exact result (22.9206766192…) on the upper side, and we will force the computer to do CPU-intensive work. We will sum all the terms whose denominators do not contain the digit “9”, and evaluate the first <span class="math inline">\(10^8\)</span> terms.</p>
<p>I implemented and timed this problem running in serial in Julia (356ms) and Chapel (300ms) – both are compiled languages. Here is one possible Python implementation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> slow(n: <span class="bu">int</span>):</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="st">"9"</span> <span class="kw">in</span> <span class="bu">str</span>(i):</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> <span class="fl">1.0</span> <span class="op">/</span> i</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> slow(<span class="dv">100_000_000</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Let’s save this code inside the file <code>slowSeries.py</code> and run it. Depending on the power supplied to my laptop’s CPU (which I find varies quite a bit depending on the environment), I get the average runtime of 6.625 seconds. That’s ~20X slower than in Julia and Chapel!</p>
<p>Note that for other problems you will likely see an even bigger (100-200X) gap between Python and the compiled languages. In other languages looking for a substring in a decimal representation of a number takes a while, and there you will want to code this calculation using integer numbers. If we also do this via integer operations in Python:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> digitsin(num: <span class="bu">int</span>):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    base <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="dv">9</span><span class="op">//</span>base <span class="op">&gt;</span> <span class="dv">0</span>: base <span class="op">*=</span> <span class="dv">10</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> num <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> num<span class="op">%</span>base <span class="op">==</span> <span class="dv">9</span>: <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        num <span class="op">=</span> num<span class="op">//</span><span class="dv">10</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> slow(n: <span class="bu">int</span>):</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> digitsin(i):</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> <span class="fl">1.0</span> <span class="op">/</span> i</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>our code will be ~3-4X slower, so in the native Python code we should use the first version of the code with <code>if not "9" in str(i)</code> – it turns out that in this particular case Python’s high-level substring search is actually quite well optimized!</p>
<section id="speeding-up-the-slow-series-with-numba" class="level3">
<h3 class="anchored" data-anchor-id="speeding-up-the-slow-series-with-numba">Speeding up the slow series with Numba</h3>
<p>You can speed up this problem with an open-source just-in-time compiler called Numba. It uses LLVM underneath, can parallelize your code for multi-core CPUs and GPUs, and often requires only minor code changes.</p>
<p>I won’t go through all the Numba details – we cover these in our separate HPC Python course. To speed up the slow series with Numba, you have to use the integer-operations version of <code>digitsin()</code>, as Numba is notoriously slow with some high-level Python constructs. Check out this implementation which is almost as fast as with the compiled languages:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numba <span class="im">import</span> jit</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> combined(k):</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    base, k0 <span class="op">=</span> <span class="dv">10</span>, k</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="dv">9</span><span class="op">//</span>base <span class="op">&gt;</span> <span class="dv">0</span>: base <span class="op">*=</span> <span class="dv">10</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> k <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> k<span class="op">%</span>base <span class="op">==</span> <span class="dv">9</span>: <span class="cf">return</span> <span class="fl">0.0</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> k<span class="op">//</span><span class="dv">10</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">1.0</span><span class="op">/</span>k0</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> slow(n):</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> combined(i)</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> slow(<span class="dv">100_000_000</span>)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>It finishes in 0.601 seconds, i.e.&nbsp;~10X faster than a naive Numba implementation with substring search (not shown here).</p>
</section>
<section id="running-numba-compiled-functions-as-ray-tasks" class="level3">
<h3 class="anchored" data-anchor-id="running-numba-compiled-functions-as-ray-tasks">Running Numba-compiled functions as Ray tasks</h3>
<p>Wouldn’t it be great if we could use Ray to distribute execution of Numba-compiled functions to workers? It turns out <em>we can</em>, but we have to be careful with syntax. We would need to define remote compiled functions, but neither Ray, nor Numba let you combine their decorators (<span class="citation" data-cites="ray.remote">@ray.remote</span> and <span class="citation" data-cites="numba.jit">@numba.jit</span>, respectively) for a single function. You can do this in two steps:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numba <span class="im">import</span> jit</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">4</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> square(x):</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">*</span>x</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> runCompiled():</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> square(<span class="dv">5</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> runCompiled.remote()</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>ray.get(r)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here we “jit” the function on the main process and send it to workers for execution. Alternatively, you can “jit” on workers:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numba <span class="im">import</span> jit</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">4</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> square(x):</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">*</span>x</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> runCompiled():</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    compiledSquare <span class="op">=</span> jit(square)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> compiledSquare(<span class="dv">5</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> runCompiled.remote()</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>ray.get(r)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>In my tests with more CPU-intensive functions, both versions produce equivalent runtimes.</p>
<p>Here is the combined Numba + Ray remotes code for the slow series (store it as <code>slowSeriesNumbaRayCore.py</code>):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numba <span class="im">import</span> jit</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>ray.init(configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100_000_000</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> combined(x):</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    base, x0 <span class="op">=</span> <span class="dv">10</span>, x</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="dv">9</span><span class="op">//</span>base <span class="op">&gt;</span> <span class="dv">0</span>: base <span class="op">*=</span> <span class="dv">10</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> x <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x<span class="op">%</span>base <span class="op">==</span> <span class="dv">9</span>: <span class="cf">return</span> <span class="fl">0.0</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x<span class="op">//</span><span class="dv">10</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">1.0</span><span class="op">/</span>x0</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> slow(interval):</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(interval[<span class="dv">0</span>],interval[<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> combined(i)</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> runCompiled(interval):</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> slow(interval)</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>ncores <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>size <span class="op">=</span> n<span class="op">//</span>ncores   <span class="co"># size of each batch</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>intervals <span class="op">=</span> [(i<span class="op">*</span>size<span class="op">+</span><span class="dv">1</span>,(i<span class="op">+</span><span class="dv">1</span>)<span class="op">*</span>size) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncores)]</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> n <span class="op">&gt;</span> intervals[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>]: intervals[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (intervals[<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>], n)   <span class="co"># add the remainder (if any)</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> [runCompiled.remote((<span class="dv">1</span>,<span class="dv">10</span>)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncores)]   <span class="co"># expose workers to runCompiled function</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="bu">sum</span>(ray.get(r))</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> [runCompiled.remote(intervals[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncores)]</span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="bu">sum</span>(ray.get(r))   <span class="co"># compute total sum</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here the averaged (over three runs) times on my laptop:</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td>ncores</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
</tr>
<tr class="even">
<td>wallclock runtime (sec)</td>
<td>0.439</td>
<td>0.235</td>
<td>0.130</td>
<td>0.098</td>
</tr>
</tbody>
</table>
<p>Using a combination of Numba and Ray tasks on 8 cores, we accelerated the calculation by ~68X.</p>
</section>
<section id="running-on-one-cluster-node" class="level3">
<h3 class="anchored" data-anchor-id="running-on-one-cluster-node">Running on one cluster node</h3>
<p>Let’s run this Numba + Ray remotes code on several CPU cores on <em>one cluster node</em>. We documented this in our wiki https://docs.alliancecan.ca/wiki/Ray – look for the section “Single Node”. It advises you to start a single-node Ray cluster with multiple CPUs via the <code>ray start ...</code> command.</p>
<p>Strictly speaking, you don’t have to do this, as Slurm will ensure that any additional processes spawned to run your Ray tasks will run on the allocated CPUs.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">training</span> cluster</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> ~/webinar</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load StdEnv/2023 python/3.12.4 arrow/17.0.0 scipy-stack/2024a netcdf/4.9.2</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="bu">source</span> /project/def-sponsor00/shared/pythonhpc-env/bin/activate</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="ex">salloc</span> <span class="at">--time</span><span class="op">=</span>0:60:0 <span class="at">--mem-per-cpu</span><span class="op">=</span>3600</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ncores <span class="ex">=</span> 1</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> slowSeriesNumbaRayCore.py   <span class="co"># 1.04s</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ncores <span class="ex">=</span> 4</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> slowSeriesNumbaRayCore.py   <span class="co"># 1.135s (still running on 1 core)</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="bu">exit</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="ex">salloc</span> <span class="at">--time</span><span class="op">=</span>0:60:0 <span class="at">--ntasks</span><span class="op">=</span>4 <span class="at">--mem-per-cpu</span><span class="op">=</span>3600</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> slowSeriesNumbaRayCore.py   <span class="co"># 0.264s (running on 4 cores)</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="bu">exit</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>On this training cluster we have 8 cores per node, so we can attempt to use all of them on a single node:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ncores <span class="ex">=</span> 8</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="ex">salloc</span> <span class="at">--time</span><span class="op">=</span>0:60:0 <span class="at">--ntasks-per-node</span><span class="op">=</span>8 <span class="at">--nodes</span><span class="op">=</span>1 <span class="at">--mem-per-cpu</span><span class="op">=</span>3600</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> slowSeriesNumbaRayCore.py   <span class="co"># 0.135 (running on 8 cores)</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="bu">exit</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="running-on-multiple-cluster-nodes" class="level3">
<h3 class="anchored" data-anchor-id="running-on-multiple-cluster-nodes">Running on multiple cluster nodes</h3>
<p>Now let’s run the same problem on 2 cluster nodes. We’ll try to distribute these 8 workers across 8 cores across 2 nodes:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ncores <span class="ex">=</span> 8</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ex">salloc</span> <span class="at">--time</span><span class="op">=</span>0:60:0 <span class="at">--ntasks-per-node</span><span class="op">=</span>4 <span class="at">--nodes</span><span class="op">=</span>2 <span class="at">--mem-per-cpu</span><span class="op">=</span>3600</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> slowSeriesNumbaRayCore.py   <span class="co"># 0.292 (not getting 8X speedup)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The problem is that Ray cluster ran all 8 workers on 4 cores on the first node. While still inside the same job, let start an interactive Python shell and then type:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">8</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>ray.nodes()   <span class="co"># reports a dictionary with node specs</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(ray.nodes()))   <span class="co"># 1 node</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.cluster_resources().get(<span class="st">"CPU"</span>))   <span class="co"># 8 CPU "cores"</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>So, we have 1 node in Ray … Ray thinks it has access to 8 CPU cores, but that’s actually the number of workers running on 4 physical CPU cores …</p>
<p>To run properly on 2 cluster nodes, we need to (1) start a single-node Ray cluster and then (2) add workers on other nodes to it outside of Python. This is described in our documentation https://docs.alliancecan.ca/wiki/Ray.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ray does not play nicely with single-core MPI tasks. Internally, Ray thinks that each MPI rank should be a “Ray node”, inside of which you would utilize multiple CPU cores. We can do this by launching just one MPI rank per cluster node and then specifying <code>--cpus-per-task=4</code>.</p>
</div>
</div>
<p>Let’s do it:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> make <span class="ex">sure</span> to go back to the login node!</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ex">salloc</span> <span class="at">--time</span><span class="op">=</span>0:60:0 <span class="at">--nodes</span><span class="op">=</span>2 <span class="at">--ntasks-per-node</span><span class="op">=</span>1 <span class="at">--cpus-per-task</span><span class="op">=</span>4 <span class="at">--mem-per-cpu</span><span class="op">=</span>3600</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">HEAD_NODE</span><span class="op">=</span><span class="va">$(</span><span class="fu">hostname</span><span class="va">)</span>   <span class="co"># store head node's address</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">RAY_PORT</span><span class="op">=</span>34567          <span class="co"># choose a port to start Ray on the head node; unique from other users</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">"Starting the Ray head node at </span><span class="va">$HEAD_NODE</span><span class="st">"</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="ex">ray</span> start <span class="at">--head</span> <span class="at">--node-ip-address</span><span class="op">=</span><span class="va">$HEAD_NODE</span> <span class="at">--port</span><span class="op">=</span><span class="va">$RAY_PORT</span> <span class="dt">\</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>          <span class="at">--num-cpus</span><span class="op">=</span><span class="va">$SLURM_CPUS_PER_TASK</span> <span class="at">--block</span> <span class="kw">&amp;</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="fu">sleep</span> 10</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">"Starting the Ray worker nodes on all other MPI tasks"</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="ex">srun</span> launchWorkers.sh <span class="kw">&amp;</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="ex">ray</span> status   <span class="co"># should report 2 nodes (their IDs) and 8 cores</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here is our code <code>launchWorkers.sh</code> to launch Ray workers on other nodes:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">[[</span> <span class="st">"</span><span class="va">$SLURM_PROCID</span><span class="st">"</span> <span class="ot">-ne</span> <span class="st">"0"</span> <span class="kw">]];</span> <span class="cf">then</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">ray</span> start <span class="at">--address</span> <span class="st">"</span><span class="va">${HEAD_NODE}</span><span class="st">:</span><span class="va">${RAY_PORT}</span><span class="st">"</span> <span class="at">--num-cpus</span><span class="op">=</span><span class="st">"</span><span class="va">${SLURM_CPUS_PER_TASK}</span><span class="st">"</span> <span class="at">--block</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sleep</span> 5</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">"ray worker started!"</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Start Python and type:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co"># connect to our pre-configured Ray cluster</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>ray.init(address<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>os<span class="sc">.</span>environ[<span class="st">'HEAD_NODE'</span>]<span class="sc">}</span><span class="ss">:</span><span class="sc">{</span>os<span class="sc">.</span>environ[<span class="st">'RAY_PORT'</span>]<span class="sc">}</span><span class="ss">"</span>,_node_ip_address<span class="op">=</span>os.environ[<span class="st">'HEAD_NODE'</span>])</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Nodes in the Ray cluster:"</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(ray.nodes()))   <span class="co"># should report 2 nodes</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.nodes())        <span class="co"># their details</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> ray.nodes()</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> nodes:</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    status <span class="op">=</span> <span class="st">"Alive"</span> <span class="cf">if</span> node[<span class="st">'Alive'</span>] <span class="cf">else</span> <span class="st">"Dead"</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(node[<span class="st">'NodeID'</span>], node[<span class="st">'NodeManagerAddress'</span>], status, <span class="bu">int</span>(node[<span class="st">'Resources'</span>][<span class="st">'CPU'</span>]), <span class="st">"cores"</span>)</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.available_resources())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><font size="+1">In this setup, each <strong>Ray node</strong> runs on a separate <strong>MPI task</strong>, one task per cluster node, and <strong>multiple CPU cores</strong> inside that task.</font></p>
</div>
</div>
<p>Let’s go back to our slow series with Numba. We’ll start from scratch and run the job via <code>sbatch</code>.</p>
<p><strong>Step 1</strong>: Prepare the following <code>submit.sh</code> job submission script:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --nodes=2</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --ntasks-per-node=1</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --cpus-per-task=4</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --mem-per-cpu=3600</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --time=0:5:0</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load StdEnv/2023 python/3.12.4 arrow/17.0.0 scipy-stack/2024a netcdf/4.9.2</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="bu">source</span> /project/def-sponsor00/shared/pythonhpc-env/bin/activate</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">HEAD_NODE</span><span class="op">=</span><span class="va">$(</span><span class="fu">hostname</span><span class="va">)</span>   <span class="co"># head node's address</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">RAY_PORT</span><span class="op">=</span>34567          <span class="co"># port to start Ray on the head node; should be unique</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">"Starting the Ray head node at </span><span class="va">$HEAD_NODE</span><span class="st">"</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="ex">ray</span> start <span class="at">--head</span> <span class="at">--node-ip-address</span><span class="op">=</span><span class="va">$HEAD_NODE</span> <span class="at">--port</span><span class="op">=</span><span class="va">$RAY_PORT</span> <span class="dt">\</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>          <span class="at">--num-cpus</span><span class="op">=</span><span class="va">$SLURM_CPUS_PER_TASK</span> <span class="at">--block</span> <span class="kw">&amp;</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a><span class="fu">sleep</span> 10</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">"Starting the Ray worker nodes on all other MPI tasks"</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a><span class="ex">srun</span> launchWorkers.sh <span class="kw">&amp;</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> slowSeriesNumbaRayCore.py</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Step 2</strong>: Prepare the following <code>launchWorkers.sh</code> script:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">[[</span> <span class="st">"</span><span class="va">$SLURM_PROCID</span><span class="st">"</span> <span class="ot">-ne</span> <span class="st">"0"</span> <span class="kw">]];</span> <span class="cf">then</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">ray</span> start <span class="at">--address</span> <span class="st">"</span><span class="va">${HEAD_NODE}</span><span class="st">:</span><span class="va">${RAY_PORT}</span><span class="st">"</span> <span class="at">--num-cpus</span><span class="op">=</span><span class="st">"</span><span class="va">${SLURM_CPUS_PER_TASK}</span><span class="st">"</span> <span class="at">--block</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sleep</span> 5</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">"ray worker started!"</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Step 3</strong>: In the code <code>slowSeriesNumbaRayCore.py</code> connect to the existing Ray cluster:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>ray.init(address<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>os<span class="sc">.</span>environ[<span class="st">'HEAD_NODE'</span>]<span class="sc">}</span><span class="ss">:</span><span class="sc">{</span>os<span class="sc">.</span>environ[<span class="st">'RAY_PORT'</span>]<span class="sc">}</span><span class="ss">"</span>,_node_ip_address<span class="op">=</span>os.environ[<span class="st">'HEAD_NODE'</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Run it with:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ex">sbatch</span> submit.sh</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Running it multiple times, I got the following runtimes: 0.188s, 0.208s, 0.153s – these are better than a 4-core, single-node run (0.292s), but worse than an 8-core, single-node run (0.135s). Any idea why?</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>For longer runtimes, while your job is still running, you can ssh into individual nodes and check Ray’s CPU usage with <code>htop --filter "ray::"</code></p>
</div>
</div>
</section>
<section id="alternative-parallel-implementation-via-ray-data" class="level3">
<h3 class="anchored" data-anchor-id="alternative-parallel-implementation-via-ray-data">Alternative parallel implementation via Ray Data</h3>
<p>In addition to bare-bones remote functions, Ray provides other tools for parallelizing your calculations. For example, you can use Ray Data to process a table of rows in parallel. We won’t go into the details here – again, these are covered in our HPC Python course – here I will provide an example of parallelizing the slow series with Ray Data without Numba compilation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> slow(row):   <span class="co"># this function processes a row in the dataset</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(row[<span class="st">'a'</span>], row[<span class="st">'b'</span>]<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="st">"9"</span> <span class="kw">in</span> <span class="bu">str</span>(i):</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> <span class="fl">1.0</span> <span class="op">/</span> i</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    row[<span class="st">'sum'</span>] <span class="op">=</span> total</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> row</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100_000_000</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>ncores <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span>ncores, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>size <span class="op">=</span> n <span class="op">//</span> ncores</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(i<span class="op">*</span>size<span class="op">+</span><span class="dv">1</span>, i<span class="op">*</span>size<span class="op">+</span>size) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncores)]</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> edges[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>] <span class="op">&lt;</span> n: edges[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (edges[<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>],n)</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>intervals <span class="op">=</span> ray.data.from_items([{<span class="st">'a'</span>:w[<span class="dv">0</span>], <span class="st">'b'</span>:w[<span class="dv">1</span>]} <span class="cf">for</span> w <span class="kw">in</span> edges])  <span class="co"># define the dataset</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>partial <span class="op">=</span> intervals.<span class="bu">map</span>(slow)                     <span class="co"># define the calculation</span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="bu">sum</span>([p[<span class="st">'sum'</span>] <span class="cf">for</span> p <span class="kw">in</span> partial.take()])   <span class="co"># request the result =&gt; start the calculation on 2 CPU cores</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Of course, you can speed up this code a lot by running Numba-compiled <code>slow()</code> via Ray Data – do this as exercise after the webinar, or attend our HPC Python course.</p>
</section>
</section>
<section id="tightly-coupled-parallel-problem" class="level2">
<h2 class="anchored" data-anchor-id="tightly-coupled-parallel-problem">Tightly coupled parallel problem</h2>
<p>We’ll be solving a 1D Poisson equation</p>
<p><span class="math display">\[{\partial^2 u(x)\over\partial x^2}=\rho(x)\]</span> on a unit interval <span class="math inline">\(x\in[0,1]\)</span>. If we set <span class="math inline">\(\rho(x)\equiv 2\)</span> and <span class="math inline">\(u(0)=u(1)=0\)</span>, the exact solution becomes <span class="math inline">\(u(x)=x^2-x\)</span>.</p>
<!-- Iterative Schwarz domain decomposition. -->
<p>My original intention for this part of the webinar was to solve this problem via an iterative Schwarz linear solver. In this approach you divide the linear problem into <code>ncores</code> linear problems, each solved with <code>np.linalg.solve()</code> on a separate Ray task. At the end of each iteration you update the first and the last elements of the RHS vector in each linear system with the new solutions at the interfaces.</p>
<p>However, a naive implementation of this solver converges very slowly. You can speed it up by using a staggered linear solver (to accelerate the convergence rate) and pre-computing the coarser solution in serial (to be used as the initial iteration for the finer solution). When you implement these techniques, the 1D parallel solver converges in 3 iterations, which (1) defies the purpose of breaking it up into multiple parts to be parallelized with Ray, and (2) will take a while to explain and code in this webinar which is not on the theory of parallel linear solvers.</p>
<p>For this reason, here I will show a brute-force iterative solution to this problem. It is <strong>much less efficient</strong>, but it will work well here to demonstrate a tightly coupled parallel solver with Ray.</p>
<p>We can rewrite the above equation in the finite difference form:</p>
<p><span class="math display">\[
{u_{i-1}-2u_i+u_{i+1}\over h^2}=\rho_i
\]</span></p>
<p>where <span class="math inline">\(i\)</span> is the grid index. Starting with the initial guess <span class="math inline">\(u_i^0=0\)</span>, we can set up iterations to compute the solution:</p>
<p><span class="math display">\[
u_i^{n+1} = {u_{i-1}^n+u_{i+1}^n-b_i\over 2}
\]</span></p>
<p>where <span class="math inline">\(b_i=\rho_ih^2\)</span>, and the solution converges as <span class="math inline">\(n\to\infty\)</span>.</p>
<section id="serial-code" class="level3">
<h3 class="anchored" data-anchor-id="serial-code">Serial code</h3>
<p>To prototype a parallel solver, first we’ll write a serial code that solves the problem on 2 intervals, and later we’ll parallelize it. We’ll do all array computations with NumPy. Let’s consider a fairly large 1D problem (total number of inner grid points <span class="math inline">\(N=2\times10^7\)</span>) and break it into 2 intervals.</p>
<p><img src="./fig/gridPartition.png" class="img-fluid"></p>
<ul>
<li>update the solution only at the inner points (filled circles)</li>
<li>always have <span class="math inline">\(u_0=u_{N-1}=0\)</span> at the edges (large open circles)</li>
<li>exchange values at the inner boundary (large filled circles)</li>
</ul>
<p>Let’s store this code in <code>poissonSerial.py</code>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">##### this is poissonSerial.py #####</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>n, relativeTolerance <span class="op">=</span> <span class="dv">20_000_000</span>, <span class="fl">1e-4</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>n1 <span class="op">=</span> n<span class="op">//</span><span class="dv">2</span><span class="op">;</span> n2 <span class="op">=</span> n <span class="op">-</span> n1</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>(n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.ones(n)<span class="op">*</span><span class="dv">2</span><span class="op">*</span>h<span class="op">*</span>h</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>u1 <span class="op">=</span> np.zeros(n1)   <span class="co"># the initial guess (first interval)</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>u2 <span class="op">=</span> np.zeros(n2)   <span class="co"># the initial guess (second interval)</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>diff <span class="op">=</span> <span class="fl">999.0</span>   <span class="co"># difference between two successive values of u1[-1]</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">abs</span>(diff) <span class="op">&gt;</span> relativeTolerance:</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>    ghostLeft <span class="op">=</span> u1[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>    ghostRight <span class="op">=</span> u2[<span class="dv">0</span>]</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> ghostLeft</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># compute new u1</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>    u1[<span class="dv">1</span>:n1<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (u1[<span class="dv">0</span>:n1<span class="op">-</span><span class="dv">2</span>] <span class="op">+</span> u1[<span class="dv">2</span>:n1] <span class="op">-</span> b[<span class="dv">1</span>:n1<span class="op">-</span><span class="dv">1</span>]) <span class="op">/</span> <span class="dv">2</span>   <span class="co"># update at inner points 1..n1-2</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>    u1[n1<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (u1[n1<span class="op">-</span><span class="dv">2</span>] <span class="op">+</span> ghostRight <span class="op">-</span> b[n1<span class="op">-</span><span class="dv">1</span>]) <span class="op">/</span> <span class="dv">2</span>       <span class="co"># update at the last point</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># compute new u2</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>    u2[<span class="dv">1</span>:n2<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (u2[<span class="dv">0</span>:n2<span class="op">-</span><span class="dv">2</span>] <span class="op">+</span> u2[<span class="dv">2</span>:n2] <span class="op">-</span> b[n1<span class="op">+</span><span class="dv">1</span>:n<span class="op">-</span><span class="dv">1</span>]) <span class="op">/</span> <span class="dv">2</span> <span class="co"># update at inner points 1..n2-2</span></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>    u2[<span class="dv">0</span>] <span class="op">=</span> (ghostLeft <span class="op">+</span> u2[<span class="dv">1</span>] <span class="op">-</span> b[n1]) <span class="op">/</span> <span class="dv">2</span>                <span class="co"># update at the first point</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> (diff<span class="op">-</span>u1[<span class="op">-</span><span class="dv">1</span>]) <span class="op">/</span> u1[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> count<span class="op">%</span><span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span>: <span class="bu">print</span>(u1[<span class="op">-</span><span class="dv">3</span>:], u2[:<span class="dv">3</span>], diff)</span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Converged after"</span>, count, <span class="st">"iterations"</span>, <span class="st">"with diff ="</span>, diff)</span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Solution:"</span>, u1[<span class="op">-</span><span class="dv">3</span>:], u2[:<span class="dv">3</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pyenv</span> activate hpc-env</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> ~/training/pythonHPC/clusterWorkflows</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> poissonSerial.py</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre class="output"><code>Time in seconds: 279.032
Converged after 9961 iterations with diff = -9.999348935138563e-05
Solution: [-2.50966143e-11 -2.50990843e-11 -2.51015743e-11] [-2.51015743e-11 -2.50990843e-11 -2.50966143e-11]</code></pre>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Caution
</div>
</div>
<div class="callout-body-container callout-body">
<p>Strictly speaking, we did not converge here (still very far from the exact solution <span class="math inline">\(u(x)=x^2-x\)</span>) – but this is not important for our parallel scaling purposes.</p>
</div>
</div>
</section>
<section id="persistent-storage-on-ray-workers" class="level3">
<h3 class="anchored" data-anchor-id="persistent-storage-on-ray-workers">Persistent storage on Ray workers</h3>
<p>In the previous serial code <code>u1</code> and <code>u2</code> are stored on the same processor. In the parallel code we’ll be computing <code>u1</code> on processor 1 and <code>u2</code> on processor 2. At each iteration we’ll be calling several Ray remote functions to do processing, but we need to store the solution <code>u1</code> on processor 1 and <code>u2</code> on processor 2 in between these function calls.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ray functions (remote tasks) are stateless, i.e.&nbsp;they can run on any processor that happens to be more idle at the time. How do we ensure that we always compute <code>u1</code> on processor 1 and <code>u2</code> on processor 2, and how do we store the arrays there permanently, without copying them back and forth at each iteration?</p>
</div>
</div>
<p>To do this, we need to use <strong>Ray actors</strong> (https://docs.ray.io/en/latest/ray-core/actors.html). A Ray actor is essentially a stateful (bound to a processor) worker that is created via a Python class instance with its own persistent variables and methods, and it stays permanently on that worker until we destroy this instance.</p>
<!-- 1. persistent storage -->
<!-- 2. launch calculations on all processors simultaneously -->
<!-- In Ray, you can store an array on a worker between two function calls using actor-based state -->
<!-- management. Since Ray functions (remote tasks) are stateless by default, you need an actor to persist the -->
<!-- array across calls. -->
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb31"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>ray.init()</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ArrayStorage:         <span class="co"># define an actor (ArrayStorage class) with a persistent array</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.array <span class="op">=</span> <span class="va">None</span>   <span class="co"># persistent array variable</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> store_array(<span class="va">self</span>, arr):</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.array <span class="op">=</span> arr    <span class="co"># store an array in the actor's state</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_array(<span class="va">self</span>):</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.array   <span class="co"># retrieve the stored array</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>storage_actor <span class="op">=</span> ArrayStorage.remote()   <span class="co"># create an instance of the actor</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>])</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>ray.get(storage_actor.store_array.remote(arr))   <span class="co"># store an array</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> ray.get(storage_actor.get_array.remote())    <span class="co"># retrieve the stored array</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(r)  <span class="co"># Output: [1 2 3 4 5]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<!-- ```py -->
<!-- print(f"Actor {worker1_actor_id} on Node {worker1_node_id} stored array: {retrieved_arr1}") -->
<!-- print(f"Actor {worker2_actor_id} on Node {worker2_node_id} stored array: {retrieved_arr2}") -->
<!-- ``` -->
<p>To scale this to multiple workers, we can do the same with an array of workers:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb32"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>workers <span class="op">=</span> [ArrayStorage.remote() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>)]   <span class="co"># create two instances of the actor</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> [workers[i].store_array.remote(np.ones(<span class="dv">5</span>)<span class="op">*</span>(i<span class="op">+</span><span class="dv">1</span>)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>)]</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(r))</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(workers[<span class="dv">0</span>].get_array.remote()))   <span class="co"># [1. 1. 1. 1. 1.]</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(workers[<span class="dv">1</span>].get_array.remote()))   <span class="co"># [2. 2. 2. 2. 2.]</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> [workers[i].get_array.remote() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>)]</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(r))   <span class="co"># both arrays in one go</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>If we want to make sure that these arrays stay on the same workers, we can retrieve and print their IDs and the node IDs by adding these two functions to the actor class:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb33"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_actor_id(<span class="va">self</span>):</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.actor_id</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_node_id(<span class="va">self</span>):</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.node_id   <span class="co"># the node ID where this actor is running</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>...</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb34"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>([ray.get(workers[i].get_actor_id.remote()) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>)])   <span class="co"># actor IDs</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>([ray.get(workers[i].get_node_id.remote()) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>)])    <span class="co"># node IDs</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<!-- Full class example: -->
<!-- ```py -->
<!-- @ray.remote -->
<!-- class ArrayStorage: -->
<!--     def __init__(self): -->
<!--         self.a = None   # persistent state -->
<!--         self.b = None   # persistent state -->
<!--         self.u = None   # persistent state -->
<!--         self.actor_id = ray.get_runtime_context().get_actor_id()  # get actor's unique ID -->
<!--         self.node_id = ray.get_runtime_context().get_node_id()    # get node ID -->
<!--     def init_a(self, n): -->
<!--         initial = np.identity(n).reshape([n*n]) -->
<!--         a = -2.0*initial -->
<!--         a[1:n*n-1] = a[1:n*n-1] + initial[:n*n-2] + initial[2:] -->
<!--         self.a = a.reshape([n,n]) -->
<!--     def store_b(self, arr):   # store an array in the actor's state -->
<!--         self.b = arr -->
<!--     def get_a(self): -->
<!--         return self.a -->
<!--     def get_u(self): -->
<!--         return self.u -->
<!--     def get_actor_id(self): -->
<!--         return self.actor_id -->
<!--     def get_node_id(self): -->
<!--         return self.node_id   # the node ID where this actor is running -->
<!--     def localSolve(self): -->
<!--         self.u = np.linalg.solve(self.a,self.b) -->
<!--     def getLastValue(self): -->
<!--         return self.u[-1] -->
<!--     def getFirstValue(self): -->
<!--         return self.u[0] -->
<!--     def updateLastB(self, ghostValue): -->
<!--         # self.b[-1] += ghostValue -->
<!--         self.b = np.concatenate([self.b[:-1], [self.b[-1]+ghostValue]]) -->
<!--     def updateFirstB(self, ghostValue): -->
<!--         # self.b[0] += ghostValue -->
<!--         self.b = np.concatenate([[self.b[0]+ghostValue], self.b[1:]]) -->
<!-- ``` -->
<p>You can even use NumPy on workers. For example, if we were to implement a linear algebra solver on a worker and <em>wanted to have the solution array stored there permanently</em>, we could do it this way:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb35"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">2</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.exp(<span class="op">-</span>(<span class="dv">100</span><span class="op">*</span>(np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,n)<span class="op">-</span><span class="fl">0.45</span>))<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>h<span class="op">*</span>h</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ArrayStorage:</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.b <span class="op">=</span> <span class="va">None</span>   <span class="co"># persistent variable</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.u <span class="op">=</span> <span class="va">None</span>   <span class="co"># persistent variable</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>        flatIdentity <span class="op">=</span> np.identity(n).reshape([n<span class="op">*</span>n])</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> <span class="op">-</span><span class="fl">2.0</span><span class="op">*</span>flatIdentity</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>        a[<span class="dv">1</span>:n<span class="op">*</span>n<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> a[<span class="dv">1</span>:n<span class="op">*</span>n<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> flatIdentity[:n<span class="op">*</span>n<span class="op">-</span><span class="dv">2</span>] <span class="op">+</span> flatIdentity[<span class="dv">2</span>:]</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.a <span class="op">=</span> a.reshape([n,n])   <span class="co"># persistent variable</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> store_b(<span class="va">self</span>, arr):</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.b <span class="op">=</span> arr                <span class="co"># store an array in the actor's state</span></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_u(<span class="va">self</span>):</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.u</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> localSolve(<span class="va">self</span>):</span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.u <span class="op">=</span> np.linalg.solve(<span class="va">self</span>.a,<span class="va">self</span>.b)</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>worker <span class="op">=</span> ArrayStorage.remote(n)</span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>worker.store_b.remote(b)</span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>worker.localSolve.remote()</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> ray.get(worker.get_u.remote())</span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The solution is"</span>, u)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="back-to-the-poisson-solver" class="level3">
<h3 class="anchored" data-anchor-id="back-to-the-poisson-solver">Back to the Poisson solver</h3>
<p>In the parallel code, we’ll be storing <code>u1</code> and <code>u2</code> permanently on two workers. On each interval, we will be updating the left and right ghost values from the other processor via remote functions <code>getLastValue</code> and <code>getFirstValue</code> – otherwise the code is functionally identical to the serial version. Let’s store this code in <code>poissonDual.py</code>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb36"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">##### this is poissonDual.py #####</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>n, relativeTolerance <span class="op">=</span> <span class="dv">20_000_000</span>, <span class="fl">1e-4</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>n1 <span class="op">=</span> n<span class="op">//</span><span class="dv">2</span><span class="op">;</span> n2 <span class="op">=</span> n <span class="op">-</span> n1</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>(n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span><span class="dv">2</span>, configure_logging<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.ones(n)<span class="op">*</span><span class="dv">2</span><span class="op">*</span>h<span class="op">*</span>h</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ArrayStorage:</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.b <span class="op">=</span> <span class="va">None</span>         <span class="co"># persistent variable</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.u <span class="op">=</span> np.zeros(n)  <span class="co"># persistent variable</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> store_b(<span class="va">self</span>, arr):   <span class="co"># store an array in the actor's state</span></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.b <span class="op">=</span> arr</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_u(<span class="va">self</span>):</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.u</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> localSolve(<span class="va">self</span>, n, ghostValue, side):</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.u[<span class="dv">1</span>:n<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (<span class="va">self</span>.u[<span class="dv">0</span>:n<span class="op">-</span><span class="dv">2</span>] <span class="op">+</span> <span class="va">self</span>.u[<span class="dv">2</span>:n] <span class="op">-</span> <span class="va">self</span>.b[<span class="dv">1</span>:n<span class="op">-</span><span class="dv">1</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> side <span class="op">==</span> <span class="dv">1</span>: <span class="va">self</span>.u[n<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (<span class="va">self</span>.u[n<span class="op">-</span><span class="dv">2</span>] <span class="op">+</span> ghostValue <span class="op">-</span> <span class="va">self</span>.b[n<span class="op">-</span><span class="dv">1</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> side <span class="op">==</span> <span class="dv">2</span>: <span class="va">self</span>.u[<span class="dv">0</span>] <span class="op">=</span> (ghostValue <span class="op">+</span> <span class="va">self</span>.u[<span class="dv">1</span>] <span class="op">-</span> <span class="va">self</span>.b[<span class="dv">0</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> getLastValue(<span class="va">self</span>):</span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.u[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> getFirstValue(<span class="va">self</span>):</span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.u[<span class="dv">0</span>]</span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a>worker1 <span class="op">=</span> ArrayStorage.remote(n1)</span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a>worker2 <span class="op">=</span> ArrayStorage.remote(n2)</span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a>worker1.store_b.remote(b[<span class="dv">0</span>:n1])</span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a>worker2.store_b.remote(b[n1:n])</span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a>diff <span class="op">=</span> <span class="fl">999.0</span>   <span class="co"># difference between two successive values of u1[-1]</span></span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a>count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">abs</span>(diff) <span class="op">&gt;</span> relativeTolerance:</span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a>    count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a>    ghostLeft <span class="op">=</span> ray.get(worker1.getLastValue.remote()) <span class="cf">if</span> count <span class="op">&gt;</span> <span class="dv">1</span> <span class="cf">else</span> <span class="fl">0.0</span></span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a>    ghostRight <span class="op">=</span> ray.get(worker2.getFirstValue.remote()) <span class="cf">if</span> count <span class="op">&gt;</span> <span class="dv">1</span> <span class="cf">else</span> <span class="fl">0.0</span></span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> ghostLeft</span>
<span id="cb36-46"><a href="#cb36-46" aria-hidden="true" tabindex="-1"></a>    worker1.localSolve.remote(n1, ghostRight, <span class="dv">1</span>)   <span class="co"># compute new u1</span></span>
<span id="cb36-47"><a href="#cb36-47" aria-hidden="true" tabindex="-1"></a>    worker2.localSolve.remote(n2, ghostLeft,  <span class="dv">2</span>)   <span class="co"># compute new u2</span></span>
<span id="cb36-48"><a href="#cb36-48" aria-hidden="true" tabindex="-1"></a>    newLeft <span class="op">=</span> ray.get(worker1.getLastValue.remote())</span>
<span id="cb36-49"><a href="#cb36-49" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> (diff<span class="op">-</span>newLeft) <span class="op">/</span> newLeft</span>
<span id="cb36-50"><a href="#cb36-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> count<span class="op">%</span><span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb36-51"><a href="#cb36-51" aria-hidden="true" tabindex="-1"></a>        u1 <span class="op">=</span> ray.get(worker1.get_u.remote())</span>
<span id="cb36-52"><a href="#cb36-52" aria-hidden="true" tabindex="-1"></a>        u2 <span class="op">=</span> ray.get(worker2.get_u.remote())</span>
<span id="cb36-53"><a href="#cb36-53" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(u1[<span class="op">-</span><span class="dv">3</span>:], u2[:<span class="dv">3</span>], diff)</span>
<span id="cb36-54"><a href="#cb36-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-55"><a href="#cb36-55" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb36-56"><a href="#cb36-56" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb36-57"><a href="#cb36-57" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Converged after"</span>, count, <span class="st">"iterations"</span>, <span class="st">"with diff ="</span>, diff)</span>
<span id="cb36-58"><a href="#cb36-58" aria-hidden="true" tabindex="-1"></a>u1 <span class="op">=</span> ray.get(worker1.get_u.remote())</span>
<span id="cb36-59"><a href="#cb36-59" aria-hidden="true" tabindex="-1"></a>u2 <span class="op">=</span> ray.get(worker2.get_u.remote())</span>
<span id="cb36-60"><a href="#cb36-60" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Solution:"</span>, u1[<span class="op">-</span><span class="dv">3</span>:], u2[:<span class="dv">3</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre class="output"><code>Time in seconds: 184.577
Converged after 9961 iterations with diff = -9.999348935138563e-05
Solution: [-2.50966143e-11 -2.50990843e-11 -2.51015743e-11] [-2.51015743e-11 -2.50990843e-11 -2.50966143e-11]</code></pre>
</section>
<section id="scalable-version" class="level3">
<h3 class="anchored" data-anchor-id="scalable-version">Scalable version</h3>
<p>Let’s adapt this code to any number of partitions. We will use arrays of workers and cycle through all available cores:</p>
<ul>
<li>a generic interval should now update ghost values on both sides, unless it is the left-most interval (only update the right ghost) or the right-most interval (only update the left ghost); we control this via the logical tuple <code>side = (True/False, True/False)</code> that we pass to <code>localSolve()</code> for each interval</li>
<li>let’s save this file in <code>poissonDistributed.py</code></li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb38"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">##### this is poissonDistributed.py #####</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ray</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>n, relativeTolerance <span class="op">=</span> <span class="dv">20_000_000</span>, <span class="fl">1e-4</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>(n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>ncores <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>size <span class="op">=</span> n<span class="op">//</span>ncores</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>intervals <span class="op">=</span> [(i<span class="op">*</span>size,(i<span class="op">+</span><span class="dv">1</span>)<span class="op">*</span>size<span class="op">-</span><span class="dv">1</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncores)]</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> n <span class="op">&gt;</span> intervals[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>]:</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>    intervals[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (intervals[<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>], n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.ones(n)<span class="op">*</span><span class="dv">2</span><span class="op">*</span>h<span class="op">*</span>h</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>ray.init(num_cpus<span class="op">=</span>ncores, configure_logging<span class="op">=</span><span class="va">False</span>, _system_config<span class="op">=</span>{ <span class="st">'automatic_object_spilling_enabled'</span>:<span class="va">False</span> })</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ArrayStorage:</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.b <span class="op">=</span> <span class="va">None</span>         <span class="co"># persistent variable</span></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.u <span class="op">=</span> np.zeros(n)  <span class="co"># persistent variable</span></span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n <span class="op">=</span> n            <span class="co"># persistent variable</span></span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> store_b(<span class="va">self</span>, arr):   <span class="co"># store an array in the actor's state</span></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.b <span class="op">=</span> arr</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_u(<span class="va">self</span>):</span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.u</span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> localSolve(<span class="va">self</span>, ghostLeft, ghostRight, side):</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="va">self</span>.n</span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.u[<span class="dv">1</span>:n<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (<span class="va">self</span>.u[<span class="dv">0</span>:n<span class="op">-</span><span class="dv">2</span>] <span class="op">+</span> <span class="va">self</span>.u[<span class="dv">2</span>:n] <span class="op">-</span> <span class="va">self</span>.b[<span class="dv">1</span>:n<span class="op">-</span><span class="dv">1</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> side[<span class="dv">0</span>]: <span class="va">self</span>.u[<span class="dv">0</span>] <span class="op">=</span> (ghostLeft <span class="op">+</span> <span class="va">self</span>.u[<span class="dv">1</span>] <span class="op">-</span> <span class="va">self</span>.b[<span class="dv">0</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> side[<span class="dv">1</span>]: <span class="va">self</span>.u[n<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (<span class="va">self</span>.u[n<span class="op">-</span><span class="dv">2</span>] <span class="op">+</span> ghostRight <span class="op">-</span> <span class="va">self</span>.b[n<span class="op">-</span><span class="dv">1</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> getLastValue(<span class="va">self</span>):</span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.u[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> getFirstValue(<span class="va">self</span>):</span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.u[<span class="dv">0</span>]</span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>workers <span class="op">=</span> [ArrayStorage.remote(intervals[i][<span class="dv">1</span>]<span class="op">-</span>intervals[i][<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncores)]</span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>[workers[i].store_b.remote(b[intervals[i][<span class="dv">0</span>]:intervals[i][<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncores)]</span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a>diff <span class="op">=</span> <span class="fl">999.0</span>   <span class="co"># difference between two successive values of u1[-1]</span></span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a>count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb38-44"><a href="#cb38-44" aria-hidden="true" tabindex="-1"></a>ghostRight <span class="op">=</span> np.zeros(ncores)</span>
<span id="cb38-45"><a href="#cb38-45" aria-hidden="true" tabindex="-1"></a>ghostLeft <span class="op">=</span> np.zeros(ncores)</span>
<span id="cb38-46"><a href="#cb38-46" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb38-47"><a href="#cb38-47" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">abs</span>(diff) <span class="op">&gt;</span> relativeTolerance:</span>
<span id="cb38-48"><a href="#cb38-48" aria-hidden="true" tabindex="-1"></a>    count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb38-49"><a href="#cb38-49" aria-hidden="true" tabindex="-1"></a>    ghostLeft[<span class="dv">1</span>:ncores] <span class="op">=</span> ray.get([workers[i<span class="op">-</span><span class="dv">1</span>].getLastValue.remote() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, ncores)])</span>
<span id="cb38-50"><a href="#cb38-50" aria-hidden="true" tabindex="-1"></a>    ghostRight[<span class="dv">0</span>:ncores<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> ray.get([workers[i<span class="op">+</span><span class="dv">1</span>].getFirstValue.remote() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncores<span class="op">-</span><span class="dv">1</span>)])</span>
<span id="cb38-51"><a href="#cb38-51" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> ghostLeft[<span class="dv">1</span>]</span>
<span id="cb38-52"><a href="#cb38-52" aria-hidden="true" tabindex="-1"></a>    workers[<span class="dv">0</span>].localSolve.remote(ghostLeft[<span class="dv">0</span>], ghostRight[<span class="dv">0</span>], (<span class="va">False</span>,<span class="va">True</span>))</span>
<span id="cb38-53"><a href="#cb38-53" aria-hidden="true" tabindex="-1"></a>    [workers[i].localSolve.remote(ghostLeft[i], ghostRight[i],</span>
<span id="cb38-54"><a href="#cb38-54" aria-hidden="true" tabindex="-1"></a>                                  (<span class="va">True</span>,<span class="va">True</span>)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,ncores<span class="op">-</span><span class="dv">1</span>)]</span>
<span id="cb38-55"><a href="#cb38-55" aria-hidden="true" tabindex="-1"></a>    workers[ncores<span class="op">-</span><span class="dv">1</span>].localSolve.remote(ghostLeft[ncores<span class="op">-</span><span class="dv">1</span>], ghostRight[ncores<span class="op">-</span><span class="dv">1</span>], (<span class="va">True</span>,<span class="va">False</span>))</span>
<span id="cb38-56"><a href="#cb38-56" aria-hidden="true" tabindex="-1"></a>    newLeft <span class="op">=</span> ray.get(workers[<span class="dv">0</span>].getLastValue.remote())</span>
<span id="cb38-57"><a href="#cb38-57" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> (diff<span class="op">-</span>newLeft) <span class="op">/</span> newLeft</span>
<span id="cb38-58"><a href="#cb38-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> count<span class="op">%</span><span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb38-59"><a href="#cb38-59" aria-hidden="true" tabindex="-1"></a>        u1 <span class="op">=</span> ray.get(workers[<span class="dv">0</span>].get_u.remote())</span>
<span id="cb38-60"><a href="#cb38-60" aria-hidden="true" tabindex="-1"></a>        u2 <span class="op">=</span> ray.get(workers[<span class="dv">1</span>].get_u.remote())</span>
<span id="cb38-61"><a href="#cb38-61" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(u1[<span class="op">-</span><span class="dv">3</span>:], u2[:<span class="dv">3</span>], diff)</span>
<span id="cb38-62"><a href="#cb38-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-63"><a href="#cb38-63" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb38-64"><a href="#cb38-64" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time in seconds:"</span>, <span class="bu">round</span>(end<span class="op">-</span>start,<span class="dv">3</span>))</span>
<span id="cb38-65"><a href="#cb38-65" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Converged after"</span>, count, <span class="st">"iterations"</span>, <span class="st">"with diff ="</span>, diff)</span>
<span id="cb38-66"><a href="#cb38-66" aria-hidden="true" tabindex="-1"></a>u1 <span class="op">=</span> ray.get(workers[<span class="dv">0</span>].get_u.remote())</span>
<span id="cb38-67"><a href="#cb38-67" aria-hidden="true" tabindex="-1"></a>u2 <span class="op">=</span> ray.get(workers[<span class="dv">1</span>].get_u.remote())</span>
<span id="cb38-68"><a href="#cb38-68" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Solution:"</span>, u1[<span class="op">-</span><span class="dv">3</span>:], u2[:<span class="dv">3</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre class="output"><code>Time in seconds: 153.139
Converged after 9961 iterations with diff = -9.999348935138563e-05
Solution: [-2.50966143e-11 -2.50990843e-11 -2.51015743e-11] [-2.51015743e-11 -2.50990843e-11 -2.50966143e-11]</code></pre>
</section>
<section id="important-performance-tip" class="level3">
<h3 class="anchored" data-anchor-id="important-performance-tip">Important performance tip</h3>
<p>When launching multiple remote functions, instead of this:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb40"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncores):</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    ray.get(workers[i].localSolve.remote())   <span class="co"># this will block on each call</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>This would result in serial execution …</p>
</div>
</div>
<p>do this:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb41"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>solve_refs <span class="op">=</span> [workers[i].localSolve.remote() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncores)]</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>ray.get(solve_refs)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>This would result in parallel execution.</p>
</div>
</div>
</section>
<section id="running-on-one-cluster-node-1" class="level3">
<h3 class="anchored" data-anchor-id="running-on-one-cluster-node-1">Running on one cluster node</h3>
<p>We will start by running interactively on one cluster node:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb42"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load StdEnv/2023 python/3.12.4 arrow/17.0.0 scipy-stack/2024a netcdf/4.9.2</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="bu">source</span> /project/def-sponsor00/shared/pythonhpc-env/bin/activate</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="ex">salloc</span> <span class="at">--time</span><span class="op">=</span>0:60:0 <span class="at">--mem-per-cpu</span><span class="op">=</span>3600</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> poissonSerial.py   <span class="co"># 2289s, 9961 iterations</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="bu">exit</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="ex">salloc</span> <span class="at">--time</span><span class="op">=</span>0:30:0 <span class="at">--ntasks</span><span class="op">=</span>2 <span class="at">--mem-per-cpu</span><span class="op">=</span>3600</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> poissonDual.py   <span class="co"># 1454s, 9961 iterations</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span class="bu">exit</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a><span class="ex">salloc</span> <span class="at">--time</span><span class="op">=</span>0:30:0 <span class="at">--ntasks</span><span class="op">=</span>4 <span class="at">--mem-per-cpu</span><span class="op">=</span>3600</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ncores <span class="ex">=</span> 4</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> poissonDistributed.py   <span class="co"># 777s, 9961 iterations</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a><span class="bu">exit</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>While it is running, you can probe its CPU/memory usage with <code>srun --jobid=... --pty htop</code> or <code>srun --jobid=... --pty htop --filter "ray::"</code>.</p>
</section>
<section id="running-on-multiple-cluster-nodes-1" class="level3">
<h3 class="anchored" data-anchor-id="running-on-multiple-cluster-nodes-1">Running on multiple cluster nodes</h3>
<p>Now let’s run the same problem on two cluster nodes following the steps we used for the slow-series problem on multiple nodes.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb43"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> ~/webinar</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load StdEnv/2023 python/3.12.4 arrow/17.0.0 scipy-stack/2024a netcdf/4.9.2</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="bu">source</span> /project/def-sponsor00/shared/pythonhpc-env/bin/activate</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="ex">salloc</span> <span class="at">--time</span><span class="op">=</span>0:60:0 <span class="at">--nodes</span><span class="op">=</span>2 <span class="at">--ntasks-per-node</span><span class="op">=</span>1 <span class="at">--cpus-per-task</span><span class="op">=</span>2 <span class="at">--mem-per-cpu</span><span class="op">=</span>3600</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">HEAD_NODE</span><span class="op">=</span><span class="va">$(</span><span class="fu">hostname</span><span class="va">)</span>   <span class="co"># head node's address</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">RAY_PORT</span><span class="op">=</span>34567          <span class="co"># port to start Ray on the head node; unique from other users</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">"Starting the Ray head node at </span><span class="va">$HEAD_NODE</span><span class="st">"</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a><span class="ex">ray</span> start <span class="at">--head</span> <span class="at">--node-ip-address</span><span class="op">=</span><span class="va">$HEAD_NODE</span> <span class="at">--port</span><span class="op">=</span><span class="va">$RAY_PORT</span> <span class="dt">\</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>          <span class="at">--num-cpus</span><span class="op">=</span><span class="va">$SLURM_CPUS_PER_TASK</span> <span class="at">--disable-usage-stats</span> <span class="at">--block</span> <span class="kw">&amp;</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a><span class="fu">sleep</span> 10</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">"Starting the Ray worker nodes on all other MPI tasks"</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a><span class="ex">srun</span> launchWorkers.sh <span class="kw">&amp;</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a><span class="ex">ray</span> status   <span class="co"># should report 2 nodes, 4 cores</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>In my testing, once connected to a Ray cluster, Ray fails to bind Ray workers to the existing processes. With 2 nodes and 2 CPUs per node, it may start 1 worker on node 1 and 3 workers on node 2, or all 4 workers on one node with 2 CPUs. It seems that specifying the number of CPU cores in the function/class definition somehow fixes that:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb44"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span>(num_cpus<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ArrayStorage:</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>...</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Let’s test this! Start Python and then run:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb45"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time, ray, os</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>ray.init(address<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>os<span class="sc">.</span>environ[<span class="st">'HEAD_NODE'</span>]<span class="sc">}</span><span class="ss">:</span><span class="sc">{</span>os<span class="sc">.</span>environ[<span class="st">'RAY_PORT'</span>]<span class="sc">}</span><span class="ss">"</span>,_node_ip_address<span class="op">=</span>os.environ[<span class="st">'HEAD_NODE'</span>])</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> my_task(task_id):</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ss">f"Task </span><span class="sc">{</span>task_id<span class="sc">}</span><span class="ss"> completed on </span><span class="sc">{</span>ray<span class="sc">.</span>get_runtime_context()<span class="sc">.</span>get_node_id()<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> [my_task.remote(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span>)]   <span class="co"># create 4 tasks, one per each CPU</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(r))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre class="output"><code>['Task 0 completed on 37531b127109840b8d4f13c959147dbe9ce25ced5e802ba4ddddf06e',
 'Task 1 completed on 37531b127109840b8d4f13c959147dbe9ce25ced5e802ba4ddddf06e',
 'Task 2 completed on 37531b127109840b8d4f13c959147dbe9ce25ced5e802ba4ddddf06e',
 'Task 3 completed on 37531b127109840b8d4f13c959147dbe9ce25ced5e802ba4ddddf06e']</code></pre>
<p>Now redefine the remote function:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb47"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span>(num_cpus<span class="op">=</span><span class="dv">1</span>)  <span class="co"># each task uses 1 CPU</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> my_task(task_id):</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ss">f"Task </span><span class="sc">{</span>task_id<span class="sc">}</span><span class="ss"> completed on </span><span class="sc">{</span>ray<span class="sc">.</span>get_runtime_context()<span class="sc">.</span>get_node_id()<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> [my_task.remote(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>)]   <span class="co"># create 4 tasks, one per each CPU</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ray.get(r))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre class="output"><code>['Task 0 completed on 37531b127109840b8d4f13c959147dbe9ce25ced5e802ba4ddddf06e',
 'Task 1 completed on 37531b127109840b8d4f13c959147dbe9ce25ced5e802ba4ddddf06e',
 'Task 2 completed on b3b0caba7c80a89fc381dad5c9312f1db713b8be18704a79e507412d',
 'Task 3 completed on b3b0caba7c80a89fc381dad5c9312f1db713b8be18704a79e507412d']</code></pre>
<p>Inside <code>poissonDistributed.py</code>, use the following to connect to the existing Ray cluster:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb49"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>ray.init(address<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>os<span class="sc">.</span>environ[<span class="st">'HEAD_NODE'</span>]<span class="sc">}</span><span class="ss">:</span><span class="sc">{</span>os<span class="sc">.</span>environ[<span class="st">'RAY_PORT'</span>]<span class="sc">}</span><span class="ss">"</span>, _node_ip_address<span class="op">=</span>os.environ[<span class="st">'HEAD_NODE'</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>and the following to ensure CPU affinity:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb50"><pre class="sourceCode py code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>ncores <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="at">@ray.remote</span>(num_cpus<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ArrayStorage:</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    ...</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Now run the numerical code:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb51"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> <span class="at">-u</span> poissonDistributed.py   <span class="co"># unbuffered stdout output</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>While it is running, in a separate shell on the cluster:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb52"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ssh</span> node1</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="ex">htop</span> <span class="at">--filter</span><span class="op">=</span><span class="st">"ray::"</span>   <span class="co"># should see 2 busy CPU cores</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="bu">exit</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="fu">ssh</span> node2</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="ex">htop</span> <span class="at">--filter</span><span class="op">=</span><span class="st">"ray::"</span>   <span class="co"># should see 2 busy CPU cores</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="bu">exit</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The output should end with:</p>
<pre class="output"><code>Time in seconds: 817s   # slightly longer than 777s when using 4 cores on the same node
Converged after 6901 iterations</code></pre>
<!-- The same calculation when run as a batch job on 24 cores (`--nodes=3 --ntasks-per-node=1 --cpus-per-task=8`) -->
<!-- finishes in 393s -- this is on a cloud machine. -->
<p>This is on a cloud machine with a slow interconnect. On Cedar we get better scaling:</p>
<!-- 9961 iterations on all these runs -->
<table class="caption-top table">
<thead>
<tr class="header">
<th>ncores</th>
<th>1</th>
<th>2</th>
<th>4</th>
<th>8</th>
<th>16</th>
<th>32</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1-node wallclock runtime (sec)</td>
<td>2521</td>
<td>1335</td>
<td>1162</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>2-node wallclock runtime (sec)</td>
<td></td>
<td></td>
<td>805</td>
<td>484</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>4-node wallclock runtime (sec)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>309</td>
<td></td>
</tr>
<tr class="even">
<td>8-node wallclock runtime (sec)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>308</td>
</tr>
</tbody>
</table>
<p>As is often the case with tightly coupled parallel problems, the speedup stalls for our small problem. To achieve further speedup, you need to increase the problem size per each CPU core.</p>
<!-- single-node -->
<!-- tail -f slurm-54243635.out - 1 core, , 2521s -->
<!-- tail -f slurm-54243795.out - 2 cores, 9961 iterations, 1335s -->
<!-- tail -f slurm-54244597.out - 4 cores, 9961 iterations, 1162s -->
<!-- multi-node -->
<!-- slurm-54249232.out 4 cores across 2 nodes, 9961 iterations, 805s -->
<!-- slurm-54250918.out 16 cores across 4 nodes, 9961 iterations, 309s -->
<!-- slurm-54252852.out 32 cores across 8 nodes, 9961 iterations, 308s -->
</section>
</section>
<section id="other-ray-workloads" class="level2">
<h2 class="anchored" data-anchor-id="other-ray-workloads">Other Ray workloads</h2>
<ul>
<li>Our Ray documentation <a href="https://docs.alliancecan.ca/wiki/Ray#Multiple_Nodes" class="uri">https://docs.alliancecan.ca/wiki/Ray#Multiple_Nodes</a> describes how to add GPUs into the scheduling mix for distributed Python Ray workflows.</li>
<li><code>@ray.remote</code> lets you run CuPy codes, see the discussion at <a href="https://github.com/ray-project/ray/issues/48217" class="uri">https://github.com/ray-project/ray/issues/48217</a></li>
<li>Mars is a tensor-based framework to scale NumPy, Pandas, and scikit-learn applications on top of Ray:
<ul>
<li><a href="https://mars-project.readthedocs.io" class="uri">https://mars-project.readthedocs.io</a></li>
<li><a href="https://docs.ray.io/en/latest/ray-more-libs/mars-on-ray.html" class="uri">https://docs.ray.io/en/latest/ray-more-libs/mars-on-ray.html</a></li>
<li>might be worth a separate webinar?</li>
</ul></li>
</ul>
<!-- - Dask tasks can run on top of Ray -->
<!-- ### Benchmarking on a laptop -->
<!-- ```txt -->
<!-- n, tolerance = 4_000, 1e-5 -->
<!-- poissonSerial.py -->
<!-- Time in seconds: 324.05 -->
<!-- Converged after 5052 iterations -->
<!-- poissonDual.py -->
<!-- Time in seconds: 269.242 -->
<!-- Converged after 5052 iterations -->
<!-- poissonDistributed.py with 4 cores -->
<!-- Time in seconds: 108.93 -->
<!-- Converged after 6901 iterations -->
<!-- ``` -->
<!-- ## CuPy -->
<!-- ```sh -->
<!-- narval -->
<!-- cd ~/scratch -->
<!-- salloc --time=0:60:0 --mem-per-cpu=3600 --gpus-per-node=1 --account=def-razoumov-ac -->
<!-- cd $SLURM_TMPDIR -->
<!-- module load python/3.12.4 cuda -->
<!-- virtualenv --no-download test-env -->
<!-- source test-env/bin/activate -->
<!-- pip install --upgrade pip --no-index -->
<!-- pip install --no-index numpy cupy -->
<!-- python code.py -->
<!-- ``` -->
<!-- ```py -->
<!-- import numpy as np -->
<!-- import cupy as cp -->
<!-- n = 2_000 -->
<!-- n2 = n*n -->
<!-- i1d = np.identity(n).reshape([n2,]) -->
<!-- a = -2.0*i1d -->
<!-- a[1:n2-1] = a[1:n2-1] + i1d[:n2-2] + i1d[2:] -->
<!-- a = a.reshape([n,n]) -->
<!-- x = np.arange(n)-n/2.0 -->
<!-- w = n/20.0 -->
<!-- b = np.exp(-x*x/(w*w)) -->
<!-- with cp.cuda.Device(0): -->
<!--     a_gpu = cp.asarray(a) -->
<!--     b_gpu = cp.asarray(b) -->
<!-- x_gpu = cp.linalg.solve(a_gpu,b_gpu) -->
<!-- x = cp.asnumpy(x_gpu) -->
<!-- ``` -->
<!-- ```py -->
<!-- # from time import time -->
<!-- import cupy as cp -->
<!-- from numba import jit -->
<!-- n = 100_000_000 -->
<!-- @jit(nopython=True) -->
<!-- def keep(num: int): -->
<!--     base = 10 -->
<!--     while 9//base > 0: base *= 10 -->
<!--     while num > 0: -->
<!--         if num%base == 9: return False -->
<!--         num = num//10 -->
<!--     return True -->
<!-- v3 = cp.vectorize(keep) -->
<!-- # start = time() -->
<!-- i = cp.arange(1,n+1) -->
<!-- filtered = i[v3(i)] -->
<!-- total = cp.sum(1 / filtered) -->
<!-- # end = time() -->
<!-- # print("Time in seconds:", round(end-start,3)) -->
<!-- print(total) -->
<!-- ``` -->
<!-- ## Testing -->
<!-- ```py -->
<!-- import ray -->
<!-- ray.init() -->
<!-- @ray.remote             # declare that we want to run this function remotely -->
<!-- def square(x): -->
<!--     return x * x -->
<!-- r = square.remote(10)   # launch/schedule a remote calculation (non-blocking call) -->
<!-- type(r)                 # ray._raylet.ObjectRef (object reference) -->
<!-- ray.get(r)              # retrieve the result (=100) (blocking call) -->
<!-- ``` -->
<!-- On my laptop - apparently it still runs on the CPU! -->
<!-- ```py -->
<!-- import ray -->
<!-- ray.init(num_gpus=1) -->
<!-- ray.available_resources()   # 8 CPU cores and 1 GPU -->
<!-- @ray.remote(num_gpus = 0.1) -->
<!-- def square(x): -->
<!--     return x * x -->
<!-- r = square.remote(10)   # launch/schedule a remote calculation (non-blocking call) -->
<!-- ray.get(r)              # retrieve the result (=100) (blocking call) -->
<!-- ``` -->
<!-- ```py -->
<!-- import ray -->
<!-- from numba import jit -->
<!-- ray.init(num_cpus=4, configure_logging=False) -->
<!-- @jit(nopython=True) -->
<!-- def square(x): -->
<!--     return x*x -->
<!-- @ray.remote -->
<!-- def runCompiled(): -->
<!--     return square(5) -->
<!-- r = runCompiled.remote() -->
<!-- ray.get(r) -->
<!-- ``` -->
<!-- ## Other -->
<!-- ScalingConfig( -->
<!--     num_workers=1, -->
<!--     use_gpu=True, -->
<!--     accelerator_type="A100" -->
<!-- ) -->
<!-- This is different from `cluster_resources` in that this will return idle (available) resources rather than -->
<!-- total resources. -->
</section>
<section id="links" class="level2">
<h2 class="anchored" data-anchor-id="links">Links</h2>
<ul>
<li><a href="https://docs.ray.io/en/latest" target="_blank">Official Ray documentation</a></li>
<li><a href="https://docs.alliancecan.ca/wiki/Ray" target="_blank">Ray on the Alliance clusters</a></li>
<li><a href="https://docs.ray.io/en/latest/cluster/vms/user-guides/community/slurm.html" target="_blank">Deploying Ray clusters on Slurm</a></li>
<li><a href="./ray" target="_blank">Our beginner’s Ray course</a> (some overlap with this webinar)</li>
<li><a href="https://docs.ray.io/en/latest/cluster/vms/user-guides/launching-clusters/on-premises.html" target="_blank">Launching an on-premise cluster</a></li>
<li>Ray on GPUs: <a href="https://docs.ray.io/en/latest/train/user-guides/using-gpus.html#train-trainer-resources" target="_blank">Ray docs</a> and <a href="https://stackoverflow.com/questions/70854334/run-a-python-function-on-a-gpu-using-ray" target="_blank">Stack Overflow</a></li>
<li><a href="https://docs.ray.io/en/latest/train/user-guides/using-gpus.html#assigning-multiple-gpus-to-a-worker" target="_blank">Assigning multiple GPUs to a worker</a></li>
</ul>
<!-- https://docs.ray.io/en/latest/ray-more-libs/multiprocessing.html -->
<!-- https://docs.ray.io/en/latest/ray-more-libs/multiprocessing.html#run-on-a-cluster -->
<!-- Leveraging GPUs with CuPy in Python https://www.kdnuggets.com/leveraging-the-power-of-gpus-with-cupy-in-python -->


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/folio\.vastcloud\.org");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>