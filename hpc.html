<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Intro to high-performance computing (HPC) – Various courses</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-4d9afe2b8d18ee9fa5d0d57b5ed4214d.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-960d9d362f81d399278ec3e29b622b37.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-e7f4145358ce1d0cd37d8d374dbb44f9.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="site_libs/bootstrap/bootstrap-960d9d362f81d399278ec3e29b622b37.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#videos-introduction" id="toc-videos-introduction" class="nav-link active" data-scroll-target="#videos-introduction">Videos: introduction</a></li>
  <li><a href="#videos-overview-of-parallel-programming-frameworks" id="toc-videos-overview-of-parallel-programming-frameworks" class="nav-link" data-scroll-target="#videos-overview-of-parallel-programming-frameworks">Videos: overview of parallel programming frameworks</a></li>
  <li><a href="#videos-slurm-job-scheduler" id="toc-videos-slurm-job-scheduler" class="nav-link" data-scroll-target="#videos-slurm-job-scheduler">Videos: Slurm job scheduler</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Intro to high-performance computing (HPC)</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- {{<cor>}}January 30<sup>th</sup> (Part 1), February 6<sup>th</sup> (Part 2) and February 13<sup>th</sup> (Part 3){{</cor>}}\ -->
<!-- {{<cgr>}}All days 10:00am - noon Pacific Time{{</cgr>}} -->
<!-- --- -->
<p>This course is an introduction to High-Performance Computing on the Alliance clusters.</p>
<p><strong>Abstract</strong>: This course is an introduction to High-Performance Computing (HPC) on the Alliance clusters. We will start with the cluster hardware overview, then talk about some basic tools and the software environment on our clusters. Next we’ll give a quick tour of various parallel programming frameworks such as OpenMP, MPI, Python Dask, newer parallel languages such as Chapel and Julia, and we’ll try to compile some serial, shared-memory and distributed-memory codes using makefiles. We’ll then proceed to working with the Slurm scheduler, submitting and benchmarking our previously compiled codes. We will learn about batch and interactive cluster usage, best practices for submitting a large number of jobs, estimating your job’s resource requirements, and managing file permissions in shared cluster filesystems. There will be many demos and hands-on exercises on our training cluster.</p>
<p><strong>Instructor</strong>: Alex Razoumov (SFU)</p>
<p><strong>Prerequisites:</strong> Working knowledge of the Linux Bash shell. We will provide guest accounts to one of our Linux systems.</p>
<p><strong>Software</strong>: All attendees will need a remote secure shell (SSH) client installed on their computer in order to participate in the course exercises. On Mac and Linux computers SSH is usually pre-installed (try typing <code>ssh</code> in a terminal to make sure it is there). Many versions of Windows also provide an OpenSSH client by default – try opening PowerShell and typing <code>ssh</code> to see if it is available. If not, then we recommend installing <a href="https://mobaxterm.mobatek.net/download.html">the free Home Edition of MobaXterm</a>.</p>
<p><strong>Materials</strong>: Please download a <a href="https://nextcloud.computecanada.ca/index.php/s/DyG3CrCHRLeqPML/download">ZIP file</a> with all slides (single PDF combining all chapters) and sample codes. A copy of this file is also available on the training cluster.</p>
<!-- tried briefly https://folio.vastcloud.org/files/introHPC.zip -->
<!-- ## Part 1 -->
<!-- Click on each line to expand: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 1: cluster filesystems -->
<!-- Let's log in to the training cluster. Try to access `/home`, `/scratch`, `/project` on the training -->
<!-- cluster. Note that these only emulate the real production filesystems and have no speed benefits on the -->
<!-- training cluster. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 2: edit a remote file -->
<!-- Edit a remote file in `nano` or `vi` or `emacs`. Use `cat` or `more` to view its content in the terminal. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 3: gcc compiler -->
<!-- Load the default GNU compiler with `module` command. Which version is it? Try to understand what the module does: run -->
<!-- `module show` on it, `echo $PATH`, `which gcc`. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 2: 4: Intel compiler -->
<!-- Load the default Intel compiler. Which version is it? Does it work on the training cluster? -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 5: third compiler? -->
<!-- Can you spot the third compiler family when you do `module avail`? -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 6: scipy-stack -->
<!-- What other modules does `scipy-stack/2022a` load? -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 7: python3 -->
<!-- How many versions of python3 do we have? What about python2? -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 8: research software -->
<!-- Think of a software package that you use. Check if it is installed on the cluster, and share your findings. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 9: file transfer -->
<!-- Transfer a file to/from the cluster (we did this already in bash class) using either command line or GUI. Type -->
<!-- "done" into the chat when done. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 10: why HPC? -->
<!-- Can you explain (1-2 sentences) how HPC can help us solve problems? Why a desktop/workstation not sufficient? -->
<!-- Maybe, you can give an example from your field? -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 11: tmux -->
<!-- Try left+right or upper+lower split panes in `tmux`. Edit a file in one and run bash commands in the -->
<!-- other. Try disconnecting temporarily and then reconnecting to the same session. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 12: compiling -->
<!-- In `introHPC/codes`, compile `{pi,sharedPi,distributedPi}.c` files. Try running a short serial code on the -->
<!-- login node (not longer than a few seconds: modify the number of terms in the summation). -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 13: make -->
<!-- Write a makefile to replace these compilations commands with `make {serial,openmp,mpi}`.   -->
<!-- Add target `all`.   -->
<!-- Add target `clean`. Try implementing `clean` for *all* executable files in the current -->
<!-- directory, no matter what they are called. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 14: Julia -->
<!-- Julia parallelism was not mentioned in the videos. Let's quickly talk about it (slide 29). -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 14b: parallelization -->
<!-- Suggest a computational problem to parallelize. Which of the parallel tools mentioned in the videos would you -->
<!-- use, and why?   -->
<!-- If you are not sure about the right tool, suggest a problem, and we can brainstorm the approach together. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 15: Python and R -->
<!-- If you use Python or R in your work, try running a Python or R script in the terminal.   -->
<!-- If this script depends on packages, try installing them in your own directory with `virtualenv`. Probably, -->
<!-- only a few of you should do this on the training cluster at the same time. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 16: other -->
<!-- Any remaining questions? Type your question into the chat, ask via audio (unmute), or raise your hand in Zoom. -->
<!-- ::: -->
<!-- {{< solution >}} -->
<!-- ```sh -->
<!-- function countfiles() { -->
<!--     if [ $# -eq 0 ]; then -->
<!--         echo "No arguments given. Usage: countfiles dir1 dir2 ..." -->
<!--         return 1 -->
<!--     fi -->
<!--     for dir in $@; do -->
<!--         echo in $dir we found $(find $dir -type f | wc -l) files -->
<!--     done -->
<!-- } -->
<!-- ``` -->
<!-- {{< /solution >}} -->
<!-- ## Part 2 -->
<!-- Click on each line to expand: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 17: serial job -->
<!-- Submit a serial job that runs `hostname` command.   -->
<!-- Try playing with `sq`, `squeue`, `scancel` commands. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 18: serial job (cont.) -->
<!-- Submit a serial job based on `pi.c`.   -->
<!-- Try `sstat` on a currently running job. Try `seff` and `sacct` on a completed job. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 19: optimization timing -->
<!-- Using a serial job, time optimized (`-O2`) vs. unoptimized code. Type your findings into the chat. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 20: Python vs. C timing -->
<!-- Using a serial job, time `pi.c` vs. `pi.py` for the same number of terms which cannot be too large or too -->
<!-- small -- why?   -->
<!-- Python pros -- can you speed up `pi.py`? -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 21: array job -->
<!-- Submit an array job for different values of `n` (number of terms) with `pi.c`. How can you have different -->
<!-- executable for each job inside the array? -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 22: OpenMP job -->
<!-- Submit a shared-memory job based on `sharedPi.c`. Did you get any speedup? Type your answer into the chat. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 23: MPI job -->
<!-- Submit an MPI job based on `distributedPi.c`.   -->
<!-- Try scaling 1 → 2 → 4 → 8 cores. Did you get any speedup? Type your answer into the chat. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 24: serial interactive job -->
<!-- Test the serial code inside an interactive job. Please quit the job when done, as we have very few compute -->
<!-- cores on the training cluster.   -->
<!-- Note: we have seen the training cluster become unstable when using too many interactive resources. Strictly -->
<!-- speaking, this should not happen, however there is a small chance it might. We do have a backup. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 25: shared-memory interactive job -->
<!-- Test the shared-memory code inside an interactive job. Please quit when done, as we have very few compute -->
<!-- cores on the training cluster. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 26: MPI interactive job -->
<!-- Test the MPI code inside an interactive job. Please quit when done, as we have very few compute cores on the -->
<!-- training cluster. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 27: debugging and optimization -->
<!-- Let's talk about debugging, profiling and code optimization. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 28: permissions and file sharing -->
<!-- Let's talk about file permissions and file sharing.   -->
<!-- Share a file in your `~/projects` directory (make it readable) with all other users in `def-sponsor00` group. -->
<!-- ::: -->
<!-- ::: {.callout-note collapse="true"} -->
<!-- ## 29: other -->
<!-- Are there questions on any of the topics that we covered today? You can type your question into the chat, ask -->
<!-- via audio (unmute), or raise your hand in Zoom. -->
<!-- ::: -->
<section id="videos-introduction" class="level2">
<h2 class="anchored" data-anchor-id="videos-introduction">Videos: introduction</h2>
<p>These videos (recorded in 2020) cover the same materials we study in the course, but you can watch these at your own pace.</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=dVMNSp98yRA">Introduction</a> (3 min)</li>
<li><a href="https://www.youtube.com/watch?v=pLy3m9Nq4rM">Cluster hardware overview</a> (17 min)</li>
<li><a href="https://www.youtube.com/watch?v=9StaWaE4KRw">Basic tools on HPC clusters</a> (18 min)</li>
<li><a href="https://www.youtube.com/watch?v=SjANgOLA4lc">File transfer</a> (10 min)</li>
<li><a href="https://www.youtube.com/watch?v=dhV0Jg8VLoU">Programming languages and tools</a> (16 min)</li>
</ul>
<p><strong>Updates</strong>:</p>
<ol type="1">
<li>Since April 1st, 2022, your instructors in this course are based at Simon Fraser University.</li>
<li>Some of the slides and links in the video have changed – please make sure to download the <a href="http://bit.ly/introhpc2">latest version of the slides</a> (ZIP file).</li>
<li>Compute Canada has been replaced by the Digital Research Alliance of Canada (the Alliance). All Compute Canada hardware and services are now provided to researchers by the Alliance and its regional partners. However, you will still see many references to Compute Canada in <a href="https://docs.alliancecan.ca">our documentation</a> and support system.</li>
<li>New systems were added (e.g.&nbsp;Narval in Calcul Québec), and some older systems were replaced (Cedar → Fir, Béluga → Rorqual, Graham → Nibi, Niagara → Trillium)</li>
</ol>
</section>
<section id="videos-overview-of-parallel-programming-frameworks" class="level2">
<h2 class="anchored" data-anchor-id="videos-overview-of-parallel-programming-frameworks">Videos: overview of parallel programming frameworks</h2>
<p>Here we give you a brief overview of various parallel programming tools. Our goal here is not to learn how to use these tools, but rather tell you at a high level what these tools do, so that you understand the difference between shared- and distributed-memory parallel programming models and know which tools you can use for each. Later, in the scheduler session, you will use this knowledge to submit parallel jobs to the queue.</p>
<p>Feel free to skip some of these videos if you are not interested in parallel programming.</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=hrN8hYYI-GA">OpenMP</a> (3 min)</li>
<li><a href="https://www.youtube.com/watch?v=0jTuecDVPYI">MPI (message passing interface)</a> (9 min)</li>
<li><a href="https://www.youtube.com/watch?v=ptR9Wa-Saek">Chapel parallel programming language</a> (7 min)</li>
<li><a href="https://www.youtube.com/watch?v=-kYclNmUuX0">Python Dask</a> (6 min)</li>
<li><a href="https://www.youtube.com/watch?v=m_60GzGJn6E">Make build automation tool</a> (9 min)</li>
<li><a href="https://www.youtube.com/watch?v=Ncwmx80zlGE">Other essential tools</a> (5 min)</li>
<li><a href="https://www.youtube.com/watch?v=hqdvNMAaegI">Python and R on clusters</a> (6 min)</li>
</ul>
</section>
<section id="videos-slurm-job-scheduler" class="level2">
<h2 class="anchored" data-anchor-id="videos-slurm-job-scheduler">Videos: Slurm job scheduler</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=Qd39UkdajwQ">Slurm intro</a> (8 min)</li>
<li><a href="https://www.youtube.com/watch?v=GjI8Fmzo20A">Job billing with core equivalents</a> (2 min)</li>
<li><a href="https://www.youtube.com/watch?v=sv5lUnoBV30">Submitting serial jobs</a> (12 min)</li>
<li><a href="https://www.youtube.com/watch?v=rIxTP8d8PaM">Submitting shared-memory jobs</a> (9 min)</li>
<li><a href="https://www.youtube.com/watch?v=7RWpRtCCPz8">Submitting MPI jobs</a> (8 min)</li>
<li><a href="https://www.youtube.com/watch?v=zaYUIjsuKoU">Slurm jobs and memory</a> (8 min)</li>
<li><a href="https://www.youtube.com/watch?v=-1g2WM9kG88">Hybrid and GPU jobs</a> (5 min)</li>
<li><a href="https://www.youtube.com/watch?v=Ye7IrSxaN2k">Interactive jobs</a> (8 min)</li>
<li><a href="https://www.youtube.com/watch?v=I_U5u9F-_no">Getting information and other Slurm commands</a> (6 min)</li>
<li><a href="https://www.youtube.com/watch?v=G4dcMri-gDM">Best computing / storage practices and summary</a> (9 min)</li>
</ul>
<!-- An interactive job will give you a bash shell on one the nodes that was allocated to your job. There you -->
<!-- can start a test run, debug your code, start a VNC/ParaView/VisIt/etc server and connect to it from a -->
<!-- client on your computer, etc. Note that interactive jobs typically have a short maximum runtime, usually -->
<!-- 3 hours. -->
<!-- One of the main takeaways from this course is to learn how to transition between `sbatch` and `salloc` -->
<!-- commands. You may debug your workflow with `salloc`, transition to production jobs with `sbatch`, and -->
<!-- then find that you need to use `salloc` again to debug problems and to analyze your large datasets. -->


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/folio\.vastcloud\.org");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>